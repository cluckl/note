[TOC]



# HashMap

## 核心变量

 ```java
  transient Node<K,V>[] table;// 真正存放数据的数组
  
  int threshold; //桶大小，可在初始化时显式指定
  
  final float loadFactor; //负载因子，可在初始化时显式指定
 ```

* 当键值对数量（元素个数）大于`threshold` * `loadFactor`时，`table`将使用resize方法进行扩容操作。
* `table.length`一定是2的整次幂，便于取模运算：数组长度-1）正好相当于一个“**低位掩码”**。

## put

`put`方法的核心是调用了`putVal`方法，主要步骤：

1. 判断`table`数组（即散列表）是否为空，空的就调用resize()方法初始化
2. 根据`key`的hash值找到`table`数组对应的桶的位置，如果该位置为空则在当前位置新建一个桶存储数据，并判断是否需要扩容，即执行`resize`方法。
3. 根据找到的桶分成三种情况写入数据：
   1. 桶的第一个节点的key相同或equals方法为true，写入新值
   2. 桶属于红黑树，按照红黑树的写入方式写入新值
   3. 桶属于链表，遍历链表找到对应的Node节点写入数据：如果链表存在到对应的Node节点，则更新该数据；否则在链表的尾部新建一个Node结点并判断是否将链表转为红黑树。
4. 桶的大小大于阈值，则调用resize()方法进行扩容。

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node<K,V> e; K k;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
```



## get

`get`方法的核心是调用了`getNode`方法，主要步骤：

1. 当`table`数组不为空，`table`数组的长度大于0且根据`key`的hash值找到对应的的第一个Node节点`first`不为空，进行下一步，否则返回`null`。	

2. 如果第一个节点`first`命中则返回`first`节点，否则进行下一步

3. 判断`first`节点的类型，如果属于`TreeNode`，则按照树的查找方式返回对应的Node节点，否则按照链表的方式寻找Node节点并返回。

   > 在jdk8之前的版本中只有链表这一个形式，因此只需要按照链表的方式查找结点即可。

`getNode`方法的源代码：

```java
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (first = tab[(n - 1) & hash]) != null) {
        if (first.hash == hash && // always check first node
            ((k = first.key) == key || (key != null && key.equals(k))))
            return first;
        if ((e = first.next) != null) {
            if (first instanceof TreeNode)
                return ((TreeNode<K,V>)first).getTreeNode(hash, key);
            do {
                if (e.hash == hash &&
                    ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null;
}
```

## hash

hash方法实际上是一个“**扰动函数**”，将**key.hashCode()**的散列值的高位和低位异或，把高位的特征和低位的特征组合起来，降低哈希冲突的概率。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

## JDK8的改动

* 底层结构由数组+链表的结构改为数组+链表+红⿊树，当链表的长度大于某个值时将该链表转换为红黑树，以减少查询时间。
* 优化了⾼位运算的hash**扰动函数**：h^(h>>>16)。
* 扩容后元素的位置要么不变，要么是在原位置的基础上再移动2次幂的位置，且**链表顺序不变**，不会出现JDK7在多线程中出现死循环的现象。

## 线程不安全

- 如果存在两个线程同时使用 put 方法添加元素，并且 key 发生了碰撞，则这两个 key 会添加到数组的同一个位置，出现其中一个线程 put 的数据被覆盖；在JDK7中，扩容时还可能导致出现死循环的现象。
- 如果多个线程同时需要扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会被赋给 `table`数组，导致其他线程 put 的数据丢失。

解决方法：使用`ConcurrentHashMap`类

## 实现自定义class作为key

实现自定义class作为key，需要实现两点：

* 重写hashcode和equals方法
  * 两个对象相等，hashcode⼀定相等
  * 两个对象不等，hashcode不⼀定不等
  * hashcode相等，两个对象不⼀定相等
  * hashcode不等，两个对象⼀定不等
* 设计的类必须是不可变的
  * 使用`final`修饰类，反正该类被继承
  * 使用`private`和`final`修饰类变量
  * 不提供改变类变量的setter方法；在getter⽅法中，只返回对象的拷⻉ 
  * 使用构造器初始化所有的类变量，进⾏深拷⻉

## Hashtable和HashMap的区别

* **null值**：HashMap允许Key- value为null；hashtable不允许；
* **线程安全**：HashMap是线程不安全的； hashtable通过`synchronized`关键字实现线程安全；
* **底层结构**：HashMap 在 JDK1.8 中底层使用**<u>数组加链表和红黑树</u>**；Hashtable 底层使用**<u>数组加链表</u>**。
* **初始容量和扩容机制**：
  *  创建时不指定初始容量：`HashMap` 默认的初始化大小为 16，每次扩充时容量变为原来的 2 倍；`Hashtable` 默认的初始大小为 11，每次扩充时容量变为原来的 2 倍+1。
  *  创建时指定初始容量：`HashMap` 将其扩充至 2 的幂次方大小；Hashtable 直接使用给定的大小。
* **hash值**： HashMap添加元素时，使用自定义的<u>**哈希扰动函数**</u>；Hashtable直接采用的key的 hashcode。

# ConcurrentHashMap

## get

由于相关数据已经使用了`volatile`修饰，保证了可见性，不需要加锁，只需要按照类似于HashMap的get方法获取数据即可。

![image-20210521164308140](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210521164308.png)

## put

### JDK7

1. 根据key使用hash函数定位到桶的位置。
2. <u>对该桶加锁：尝试**自旋**获取锁，自旋失败达到一定次数后再改为**阻塞**获取锁。</u>
3. 遍历桶中的数据节点：
   1. 如果当前节点不为空：如果传入的 key 和当前遍历的 key 相等，则覆盖旧的 value。
   2. 如果当前节点为空：新建一个 节点并加入到 Segment 中，并判断是否需要扩容。
4. 释放之前获取的锁。

### JDK8

1. 判断`table`数组是否为空，若为空则初始化
2. 根据`key`的`hashcode`得到hash值，以得到桶的位置
3. 根据该桶的特点执行相应的操作：
   1. 如果桶的位置为空，则尝试使用**<u>CAS机制</u>**插入数据
   2. 如果桶的位置不为空：
      1. 判断是否需要执行相应的扩容操作
      2. **<u>使用`synchronized` 锁住桶的第一个节点然后写入数据</u>**
      3. 如果节点数量大于阈值则转换成红黑树
4. 更新元素数量并判断是否需要扩容

## ConcurrentHashMap 和 Hashtable 的区别

`ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现**<u>线程安全</u>**的方式上不同。

- <u>**底层数据结构**</u>： JDK7 的 `ConcurrentHashMap` 底层采用 <u>**分段的数组+链表**</u> 实现，JDK8+ 采用 <u>**数组+链表/红黑二叉树**</u>。`Hashtable`的底层数据结构都是采用<u>**数组+链表**</u>的形式

- **<u>并发控制</u>**：

  - get方法：ConcurrentHashMap使用`volatile`修饰节点，get方法不需要加锁；Hashtable对整个get方法使用`synchronized` 修饰
  - put方法：在JDK7中，ConcurrentHashMap使用分段锁只锁住对应的桶，在JDK8中，使用 `synchronized` 和 CAS机制；而Hashtable对整个put方法使用`synchronized` 修饰

  



# 参考

* [HashMap原理详解，看不懂算我输（附面试题）](https://zhuanlan.zhihu.com/p/127147909)
* [HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！](https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/)

