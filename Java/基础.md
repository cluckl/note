[TOC]

### 值传递和引用传递

* 值传递（pass by value）：将实际参数复制一份传递到函数中，在函数中对参数进行修改不会影响到实际参数。
* 引用传递（pass by reference）：将实际参数的地址直接传递到函数中，在函数中对参数的修改会影响到实际参数。

本质区别：值传递会创建副本，引用传递不会。

<u>在Java中所有传递都是值传递</u>：

* 对于基本类型的传递，传递的参数是值本身；
* **对于对象类型，传递的参数是对象的引用**。



### 面向对象的三大特性

* 封装：将数据和基于数据的操作封装在一起，使其成为一个整体，用户不需要关心内部的细节，但可以通过对象对外提供的接口来访问该对象。
* 继承：通过`extend`实现继承，通过继承可以扩展父类没有的功能。
* 多态：编译时多态和运行时多态。编译时多态主要指方法的重载，运行时多态主要指方法的重写。



### `==` 和 `equals` 的区别

* `equals` 用来进行内容比较，`==` 用来进行地址比较。
* `equals` 是一个方法，`==` 是一个操作符。
* `equals` 的运行速度没有`==` 快。



### HashCode

hash code是一种编码方式，在Java中，每个对象都会有一个hashcode，Java可以通过它来识别一个对象。一般用于hash相关的集合中。



### String、 Stringbuffer、 Stringbuilder三者的区别
* String创建底层是final修饰的char数组，创建对象后会放在常量池中不可修改。
* Stringbuffer/底层是char数组，用于**多线程**大数据量的增删改查，<u>线程安全靠 synchronized关键字实现的</u>。
* Stringbuilder底层是char数组，用于**单线程**大数据量的增刪改查，**线程不安全**。

### 重写与重载的区别

* 重载( Overload):函数名相同，参数不同。可以改变返回值类型，参数的个数和类型。

* 重写( Override):和父类的的方法名称、参数完全相同。

  

### 创建对象的几种方式
* 使用new关键字
* 使用反射机制创建对象：
  (1)使用Cass类的 newlnstance方法
  (2)`java.lang.reflect.Constructor`类的newinstance方法
* 使用 clone方法：先实现 Cloneable接口并实现其 clone方法
* 使用反序列化



### final的用法

* final修饰的类：不可以被继承的，这样做的目的可以保证该类不被修改;
* final修饰方法：子类不可以重写父类中被 final修饰的方法。
* final修饰实例变量：必须初始化，且不可再修改。
* fina修饰局部变量：时只能初始化（赋值）一次，但也可以不初始化。
* fina修饰方法参数时，是在调用方法传递参数时候初始化的。

### static的用法

static表示“静态”的意思，可用于修饰变量、方法、代码块和内部类：

* **静态变量**：属于类，类所有的实例都共享静态变量
* **静态方法**：不依赖于任何实例，不能是抽象方法
* **静态语句块**：在类的初始化时运行一次
* **静态内部类**：不依赖于外部类的实例

共同特点：**<u>在类加载过程中完成唯一一次内存分配</u>**

### 静态代码块与非静态代码块(构造代码块)的不同点

*  **<u>执行顺序</u>**：静态代码块在非静态代码块之前执行
* **<u>执行时机</u>**：静态代码块只在在**<u>第一次实例化对象</u>**时运行一次；非静态代码块在**<u>每次实例化对象</u>**时运行。
* **<u>定义场合</u>**：非静态代码块可在普通方法中定义；静态代码块不行

### 静态代码块、构造代码块、构造函数的初始化顺序

先按照父类到子类的顺序初始化静态代码块，然后初始化父类的构造代码块、构造函数，最后初始化子类的构造代码块、构造函数：

1. 父类静态代码块
2. 子类静态代码块
3. 父类构造代码块
4. 父类构造函数
5. 子类构造代码块
6. 子类构造函数

### int与 integer的区别

* int是基本数据类型，初始默认值是0;integer是包装数据类型，初始默认值是nul;
* int转换成 integer是装箱过程， integer转换成int是拆箱过程

### Arraylist与 LinkedList的数据结构
* arraylist底层是 Object数据类型的数组结构，元素查询和修改效率高，线程不安全。
* linkedlist底层是Node节点的链表结构，元素删除和插入效率高，线程不安全。

### `List`接口的安全实现类
* `Vector`是`List`接口的线程安全实现类，是通过 `synchronized`关键字实现的。
* `CopyOnWriteArrayList`是JUC包里的，相当于线程安全的 `ArrayList`。

### 如何设置一个不可变类

* 使用`final`修饰类，使其不可被继承
* 对于所有的成员变量，使用`final`和`private`修饰，不提供setter方法，getter方法返回<u>数据的拷贝</u>
* 通过构造器初始化全部成员变量，且必须通过<u>深拷贝</u>的方式传入引用类型的参数

### Arraylist的foreach循环遍历时不可以删除元素的原因及解决方式

* 原因
  * foreach是基于迭代器实现的，当迭代器调用next()方法时，next()方法会调用`checkForComodification()`方法，该方法存在两个变量分别表示**<u>期望集合修改次数</u>**和**<u>实际集合修改次数</u>**，实际集合修改次数的值**只有通过迭代器对集合进行操作**才会改变。
  * 直接删除元素会导致这两个变量的值不同，导致抛出`Concurrentmodificationexception`异常。
* 解决方式
  * 通过for循环遍历删除。如果顺序遍历，每次删除值的时，**<u>索引值需要减1</u>**
  * 用迭代器 `Iterator`遍历删除

### 构造方法的特性

* 结构：名字和类名相同，没有返回值
* 调用方式：生成类的实例时自动执行
* 线程安全：天生线程安全


### wait() 和 sleep() 的区别
* wait() 是 Object 的方法； sleep() 是 Thread 的静态方法
* wait()方法只能在被`synchronized`修饰的同步代码块或同步方法中使用，会释放锁，用于<u>**线程同步**</u>；sleep()的使用不受限制

### 用什么数据类型来存储金额？

一般BigDecimal来表示金额

### 为什么要有迭代器

用于顺序访问集合对象的元素，**<u>不需要知道集合对象的底层表示</u>**。

迭代器是一种设计模式，它是一个对象，它的工作是**遍历并选择序列中的对象**，而使用者不必知道该序列的底层结构。此外，迭代器通常被称为“轻量级”对象，因为创建它的代价小。

### Comparable和Comparator

* Comparable是排序接口。若一个类实现了Comparable接口，就意味着该类支持排序。实现了Comparable接口的类的对象的列表或数组可以通过Collections.sort或Arrays.sort进行自动排序。　
* Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。　
* comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。



### 定义没有参数的空白构造方法的作用

类在调用自身的构造方法时，如果没有显式调用父类的构造方法，则会**<u>自动调用父类的无参构造方法</u>**。