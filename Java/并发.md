[TOC]

# 线程

## 并发编程的三个重要特性

1. **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized` 可以保证代码片段的原子性。
2. **可见性** ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。
3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

## 创建线程

* 显式创建线程
  * new Thread（）
  * 实现Runnable或者Callable接口
  * 通过Future创建
* 使用线程池创建

## 线程的状态

1. NEW：尚未启动的线程
2. RUNNABLE：在 Java 虚拟机中执行的线程，可能等待被OS调度，对应OS中线程的**<u>ready</u>**或**<u>running</u>**状态
3. BLOCKED：被阻塞等待监视器锁的线程
4. WAITING：无限期等待另一个线程执行特定操作的线程
5. TIMED_WAITING：有限时间内等待另一个线程执行操作的线程
6. TERMINATED：已执行完成的线程

### 显式创建线程
显式创建线程有三种方法：
* extends Thread
	需要重写`public void run()`方法
```java
Thread thread = new Thread1();  
thread.start();
```
* implements Runnable
	需要重写`public void run()`方法
 ```java
Runnable runnable;
Thread thread3 = new Thread(runnable);
 ```
* implements Callable
	可通过get()方法获取返回值；需要重写call()方法；
	
 ```java
 class CallableTest implements Callable<Integer>{  
	 @Override  
	 public Integer call(){  
	 	// do sth.  
	 }  
}
 ```
 需要借助`FutureTask`类并将该类的对象作为Thread的参数使用：
 `FutureTask<Integer> ft = new FutureTask<>(new CallableTest());`

# 线程池

**线程池（Thread Pool）**：维护多个线程的池子，属于一种软件设计模式，用于实现程序中的执行并发。

* **降低资源消耗**：重复利用池中已有线程可以减少创建和销毁线程导致的开销。
* **提高响应速度**：当线程池中存在线程时，任务一旦到达可立即执行。
* **提高可管理性**：利于对线程进行统一的分配、调优和监控。
* **提高可拓展性**：允许程序员增加更多的功能，如`ScheduledExecutorService`允许任务定时执行。

### 线程池执行流程

![img](https://pic1.zhimg.com/80/v2-a9fe9da875c1f99e21f58f448fba0c14_720w.jpg)

## 线程池参数

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

- **corePoolSize**：线程池里的**核心线程数量**

- **maximumPoolSize**：线程池里的**最大线程数量**

- keepAliveTime： 当线程池线程数量大于`corePoolSize`时候，多出来的空闲线程，多长时间会被销毁。

- unit： `keepAliveTime`的时间单位，如：`TimeUnit.MICROSECONDS`

- **workQueue **：任务队列，用于存放提交但是尚未被执行的任务。

  ![img](https://p0.meituan.net/travelcube/725a3db5114d95675f2098c12dc331c3316963.png)

- threadFactory ：用于创建线程的工厂，一般使用默认即可:
  `Executors.defaultThreadFactory()`

- handler 拒绝策略

  * AbortPolicy：直接**抛出异常**，默认策略
  * CallerRunsPolicy：用**调用者所在的线程**来执行任务
  * DiscardOldestPolicy：丢弃**阻塞队列中最早的未处理的任务**，并执行当前任务
  * DiscardPolicy：直接**丢弃**任务

  其中**核心线程数、最大线程数以及拥塞队列**较为重要，他们能反映出一个线程池的特性

### 线程池的生命周期

线程池内部有两个变量:**运行状态(runState)**和**线程数量 (workerCount)**
运行状态：

<img src="https://p0.meituan.net/travelcube/62853fa44bfa47d63143babe3b5a4c6e82532.png" alt="img" style="zoom: 67%;" />
生命周期转换过程：
![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210510103616.png)

## Executors工具类提供的4种典型线程池

#### SingleThreadPool

核心线程数和最大线程数都是1，使用`LinkedBlockingQueue`。适用于**串行执行任务**

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}
```

#### FixedThreadPool

核心线程数和最大线程数相同，使用`LinkedBlockingQueue`。适用于执行**长期的任务**

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}
```

#### CachedThreadPool

不存在核心线程，最大线程数是`Integer.MAX_VALUE`，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收，使用`SynchronousQueue`。适用于执行**<u>大量短生命周期</u>**任务。

`SynchronousQueue`：不存储元素，每一个put操作必须等待take操作。支持公平锁和非公平锁。

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}
```

#### ScheduledThreadPool

可以指定核心线程数，最大线程数是`Integer.MAX_VALUE`，使用`DelayedWorkQueue`，可以**<u>限制任务被线程取走的最短时间</u>**，适用于周期性执行任务或者需要限制线程数量的场景。

```java
public ScheduledThreadPoolExecutor(int corePoolSize) {
    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,
          new DelayedWorkQueue());
}
```

## 线程池的使用

线程池一般使用`ExecutorService`类变量引用线程池，可使用Executors工具类或自定义创建线程池：

1. 使用`Executors`工具类

```java
ExecutorService executorService = Executors.newFixedThreadPool(5);  
executorService.execute(runnable1);  
executorService.execute(runnable2); 
executorService.shutdown();
```

Executors中`SingleThreadExecutor`和`FixedThreadExecutor`中的队列大小是无限的，而另外两个线程池的线程数最大数是`Integer.MAX_VALUE`，因此可能导致内存飙升，甚至OOM，<u>一般不推荐使用</u>。

2. 自定义线程池

```java
ExecutorService service = new ThreadPoolExecutor(5, 15,
	1L, TimeUnit.MICROSECONDS,
	new LinkedBlockingDeque<>(20),
	Executors.defaultThreadFactory(), 
	new ThreadPoolExecutor.AbortPolicy());
```

使用`execute`(Runnable) 或 `submit`(Callable)方法执行一个线程。

execute()方法和 submit()方法的区别：

* `execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功；
* `submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功。

关闭线程池时一般使用`shutdown()`方法，注意该方法的作用是停止接收新的任务，但在缓冲队列或线程正在执行的任务不会停止。

#   synchronized

## 作用

synchronized：给实例或者类加锁。

![img](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/multi-thread/images/interview-questions/synchronized%E5%85%B3%E9%94%AE%E5%AD%97.png)



* **<u>原子性</u>**：确保线程互斥访问同步代码
* **<u>可见性</u>**：通过Java内存模型中的 “<u>**对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中初始化变量值**</u>” 保证共享变量的修改能够及时可见
* **<u>有序性</u>**：通过 “一个unlock操作先行发生**<u>(happen-before</u>**)后面对同一个锁的lock操作”解决重排序问题

## 使用方式

* **修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得<u>**当前对象实例的锁**</u>
* **修饰静态方法或类**：作用于**当前类的锁**，进入同步代码前要获得 <u>**当前 class 的锁**</u>。
* **修饰代码块** (`synchronized(this|object|className.class)`)：对给定对象/类加锁。 进入同步代码前要获得**给定对象或类的锁**。

## 锁的状态

为了减少获得锁和释放锁带来的性能消耗，在Java 6 及其以后，一个对象有四种锁状态，它们级别由低到高依次是：

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态

### 偏向锁

偏向锁：**<u>消除了同步语句和CAS</u>**操作，能够明显提高程序的运行性能，但如果线程间存在锁竞争，**<u>锁撤销</u>**会带来额外的的消耗。适用于资源不存在多线程竞争，且总是由同一线程多次获得的场景。

#### 过程

线程进入同步块时，检查自己的线程ID是否和锁的Mark Word里面的线程ID相等。

* 若相等，表明该线程已经获得了锁。以后该线程在进入和退出同步块时**<u>不需要使用CAS操作加锁和解锁</u>** 
* 若不相等，表明可能存在不止一个线程竞争该偏向锁。尝试使用CAS操作替换Mark Word里面的线程ID为新线程的ID：
  *  CAS成功，表示之前的线程不存在, Mark Word里面的线程ID为新线程的ID，锁不会升级
  * CAS失败，表示之前的线程仍然存在，**<u>撤销偏向锁</u>**：
    1. 在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。
    2. 遍历线程栈，如果存在锁记录，修复锁记录和Mark Word，使其变成无锁状态。
    3. 唤醒被停止的线程，将当前锁升级成轻量级锁。 

### 轻量级锁

轻量级锁：不会造成线程阻塞，能够有效**<u>提高响应时间</u>**，但会**<u>降低CPU的吞吐量</u>**。适用于资源竞争程度较低，同一时间段竞争同一资源的线程数量较少的场景。

#### 获取过程

线程进入同步块时，如果要获取的锁是轻量级锁，则将锁对象的Mark Word作为**<u>锁记录</u>**存储到当前线程的栈帧中(Displaced Mark Word)，并使用CAS操作尝试**<u>将锁对象的Mark Word替换为指向锁记录的指针</u>**。

* 如果CAS成功，当前线程获得锁

* 如果失败，表明锁被线程占有，当前线程尝试使用**<u>适应式自旋</u>**的方式获取锁。当自旋到一定程度依然没有获取到锁，**<u>该线程会阻塞，将当前锁升级成重量级锁</u>**。

  > 自旋：不断尝试去获取锁，一般用循环来实现。
  >
  > 适应性自旋：如果自旋成功，增加下次自旋的次数；如果自旋失败，减少下次自旋的次数。

#### 释放过程

当前线程尝试使用CAS操作将**<u>锁记录</u>**复制回锁对象的Mark Word里面。

* 若CAS操作失败，说明存在其他线程在尝试获取该锁的过程中因为自旋多次导致轻量级锁升级成了重量级锁，则**<u>释放该锁并唤醒被阻塞的线程</u>**。

### 重量级锁

重量级锁：通过**对象监视器 `monitor`** 实现，而监视器本质依赖操作系统**<u>的互斥量（mutex）</u>** 实现，涉及OS内部的线程切换，因此响应时间长，但被阻塞的线程不会消耗CPU，能提高CPU的吞吐量。

> 当调用一个锁对象的`wait`或`notify`方法时，**如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁**。

## 锁消除

**锁消除**：当通过<u>**逃逸分析**</u>发现在堆上的共享数据不会逃逸出去被其它线程访问到的情况下，将它们当成私有数据，消除它们的锁。

## 锁粗化

**锁粗化**：当JVM探测到一串零碎的操作序列都对同一个对象加锁时，把锁的范围**<u>粗化</u>**到整个操作序列的外部。

优点：只需锁住该对象一次，防止频繁的加锁导致的性能损耗。

## synchronized 和 ReentrantLock 的区别

|          | synchronized     | ReentrantLock                |
| -------- | ---------------- | ---------------------------- |
| 实现机制 | 依赖JVM的Monitor | 基于AQS                      |
| 锁释放   | 自动释放Monitor  | 显式调用unlock()             |
| 锁类型   | 非公平锁         | 公平锁&非公平锁（默认）      |
| 高级特性 | 无               | 响应中断、超时、获取锁的状态 |

# volatile

![img](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15851555-5abc-497d-ad34-efed10f43a6b.png)

`volatile`的作用：

1. **保证变量的可见性**：线程在读取变量时到主存读取，写入时写入到主存中，以解决缓存一致性问题。
2. **防止 JVM 指令重排**：通过内存屏障实现。

##  volatile和synchronized的区别

- `volatile` 是线程同步的**<u>轻量级</u>**实现，性能较好 。
- `volatile` 修饰**<u>变量</u>**； `synchronized` 修饰**<u>方法、类和代码块</u>** 。
- `volatile` 不能保证数据的**<u>原子性</u>**；`synchronized` 可以。

# ThreadLocal

ThreadLocal：提供线程局部变量，每个线程`Thread`拥有一份自己的**副本变量**，多个线程互不干扰。

一般情况下ThreadLocal实例被`static`和`final`修饰，用于将状态和线程关联。

## 原理

`ThreadLocal`将变量保存在`Thread`类的`ThreadLocalMap`变量中。在`ThreadLocalMap`中，key是`ThreadLocal`实例，value是对应的值。

```
public class Thread implements Runnable {
    //......
    ThreadLocal.ThreadLocalMap threadLocals = null;
    //......
}
```

![image-20211007160500846](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20211007160501.png)

### 引用类型

`ThreadLocalMap` 中使用的 key使用弱引用,value 使用**强引用**。

 *  key 使用弱引用的原因：如果使用强引用，在`ThreadLocal`实例没有被外部强引用的情况下，仍然会被key强引用，因此不会被GC清除。从而导致内存泄露。
 *  value 使用强引用的原因：确保在key存在的情况下value不会被清除。

如果 `ThreadLocal` 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉，可能会产生**<u>内存泄露</u>**。

解决方法：使用完 `ThreadLocal`实例后，调用`remove()`方法删除对应线程的`ThreadLocal`实例。

# AQS

**AQS(AbstractQueuedSynchronizer, 抽象队列同步器)**：一个用来构建锁和同步器的框架，能简单高效地构造出大量应用广泛的同步器，如 `ReentrantLock`，`Semaphore`等等。

## 原理

### 核心思想

* 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。

* 如果被请求的共享资源被占用，那么就需要一套**<u>线程阻塞等待以及被唤醒时锁分配</u>**的机制。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。

  ![image-20211006162838760](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20211006162839.png)

AQS使用一个`volatile`的int类型变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过**<u>CAS</u>**操作完成对State值的修改。

### 子类实现

AQS的资源有两种共享模式：

- 独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如`ReentrantLock`。
- 共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如`Semaphore`、`CountDownLatch`。

由于AQS基于**模板方法模式**实现，因此存在有一些方法需要子类去实现：

- `tryAcquire(int)`：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- `tryRelease(int)`：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- `tryAcquireShared(int)`：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- `tryReleaseShared(int)`：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

子类可以需要根据需求实现其中一种或者两种模式。

## 组件

###  CountDownLatch

一个或者多个线程，等待其他多个线程完成某件事情之后才能执行

* 维护一个计数器 ，每次调用 `countDown()` 方法会让计数器的值减 1。
* 当计数器为 0，所有调用 `await()` 方法而在等待的线程才能继续执行。

### CyclicBarrier

多个线程互相等待，直到到达同一个同步点，再继续一起执行。

* 维护一个计数器 ，调用 `await()` 方法之后计数器会减 1，并进行等待。
* 当计数器为 0，所有调用 `await()` 方法而在等待的线程才能继续执行，且`barrierAction`线程开始执行。

* 可通过调用 `reset()` 方法循环使用。

### Semaphore

Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。

# JUC包

## Fork/join

该框架采用分治法，即**divide and conquer approach**.最大化利用CPU加速并行任务。

<u>divide即fork，conquer即join。</u>

### ForkJoinTask\<V>

ForkJoinTask\<V>是任务的基本类型。对于我们想要实现forkjoin的自定义类，必须继承它的两个子类之一：

* RecursiveAction：无返回值。
* RecursiveTask\<V>：返回类型V。

<u>从扩展性的角度考虑，个人推荐使用RecursiveTask\<V>。</u>

ForkJoinTask子类必须重写如下方法：

```java
protected abstract V compute();
```

**使用者需要自行在该方法中实现fork和join的逻辑。**

### ForkJoinPool

该类是Fork/join框架的核心，是ExecutorService 的一个实现类，使用了**工作窃取算法**（work-stealing）。

> Worker threads that run out of things to do can steal tasks from other threads that are still busy.

**简单地说——空闲线程试图从繁忙线程的双端队列中“窃取”工作。**

默认情况下，工作线程从它自己的双端队列的头部获取任务。当它为空时，线程从另一个繁忙线程的双端队列的尾部或全局入口队列中获取任务，因为这是最大的工作块可能所在的位置。

这种方法最大限度地减少了线程竞争任务的可能性。它还减少了线程必须去寻找工作的次数，因为它首先处理最大的可用工作块。

---

使用方式：一般创建预定义的公共池会减少资源消耗，因为这会阻止为每个任务创建单独的线程池：

```java
ForkJoinPool commonPool = ForkJoinPool.commonPool();
```

## 使用

1. 实现ForkJoinTask的两个子类之一：
   * RecursiveAction：不需要返回值的场合，类似于Runnable
   * RecursiveTask：需要返回值的场合，类似于Callable
2. 重写`compete`方法
   * 调用`invokeAll`方法添加子任务
   * 调用`join`方法获取子任务的结果

## 实例

```java
import lombok.Data;
import lombok.EqualsAndHashCode;
import service.Person;

import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
        ForkJoinTask<Integer> futureTask = new SuperExec(3425);

        forkJoinPool.execute(futureTask);
        Thread.sleep(5);

    }

}
@EqualsAndHashCode(callSuper = true)
@Data
class SuperExec extends RecursiveTask<Integer>{
    static final int THRESHOLD = 500;
    private int contain;

    SuperExec(int contain){
        this.contain = contain;
    }


    /**
     *
     * The main computation performed by this task.
     *
     * @return the result of the computation
     */
    @Override
    protected Integer compute() {
        if(contain < 500){
            System.out.println("this origin contain is " + contain + "\t" + Thread.currentThread().getName());
            return contain;
        }
        int one = contain / 2;
        int other = contain - one;
        SuperExec subTask1 = new SuperExec(one);
        SuperExec subTask2 = new SuperExec(other);
        invokeAll(subTask1, subTask2);
        int res1 = subTask1.join();
        int res2 = subTask2.join();
        System.out.println("the origin is borken into two:"  +  res1 + "\t" + res2);
        return res1 + res2;

    }
}
```



## CompletableFuture



# 参考资料

* [Java线程池，你五分钟讲完，而我和面试官聊了半小时_ ...](https://blog.csdn.net/zycxnanwang/article/details/105563351)
* [Java线程池实现原理及其在美团业务中的实践](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
* [Thread pool - Wikipedia](https://en.wikipedia.org/wiki/Thread_pool)
* [Fork/Join (The Java™ Tutorials > Essential Classes](https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html)
* [Guide to the Fork/Join Framework in Java](https://www.baeldung.com/java-fork-join)
* [深入浅出Java多线程](https://redspider.gitbook.io/concurrent/di-er-pian-yuan-li-pian/9#92-ji-zhong-suo)