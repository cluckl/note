# 动态代理

## 简介

代理分为静态代理和动态代理，静态代理即设计模式中的代理模式。

从 JVM 角度来说，动态代理是在**运行时动态生成 `.class` 字节码文件** ，并加载到 JVM 中的。

![image-20210908220227638](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210908220230.png)

## 引入动态代理的原因

为了解决静态代理的带来的以下问题 ：

- 代理类需要实现与委托类一样的接口，会导致代理类数量较多，不易维护
- 一旦接口增加方法，委托类和代理类都需要维护

## 使用场景

* Spring AOP、RPC等框架

## JDK动态代理

前置条件：<u>委托类必须实现某一接口，在生成代理对象时类型只能强制转换成该接口，不能是接口的实现类。</u>

JDK 动态代理的核心是处理类 **`InvocationHandler`** 和 **`Proxy`**。

步骤：

1. 创建一个处理类并实现 `InvocationHandler` 接口，并重写 `invoke` 方法，使得委托类能够注入该处理类中。

   ```java
   public class Handler implements InvocationHandler {
       private final Object target;
   
       /**
        * 
        * @param target 委托类实例
        */
       public Handler(Object target) {
           this.target = target;
       }
   
   
       @Override
       public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
           //todo: before
           Object res = method.invoke(this.target, args);
           //todo: after
           return res;
       }
   }
   ```

   

2. 通过 `Proxy` 类的 `newProxyInstance()` 创建的代理对象。

   ```java
   public static Object newProxyInstance(ClassLoader loader,
                                             Class<?>[] interfaces,
                                             InvocationHandler h)
   ```



## Cglib动态代理

Cglib动态代理可以<u>代理没有实现接口</u>的类，通过**继承**的方式去增强目标类。

> CGLIB（Code Generation Library）是一个基于 ASM 的 Java 字节码生成框架，它允许在运行时对字节码进行修改和动态生成。

CGLIB 动态代理的核心是方法拦截器 **`MethodInterceptor`** 和**`Enhancer`**

1. 创建一个方法拦截器实现 `MethodInterceptor`接口，并重写 `intercept` 方法。`intercept` 用于**拦截**并**增强**委托类的方法（和 JDK 动态代理 `InvocationHandler` 中的 `invoke` 方法类似）

2. 创建代理对象（Proxy）：通过 `Enhancer.create()` 创建委托类对象的代理实例

   ```JAVA
   public class CglibProxyFactory {
       public static Object getProxy(Class<?> clazz) {
           // 创建动态代理增强类
           Enhancer enhancer = new Enhancer();
           enhancer.setClassLoader(clazz.getClassLoader());
           // 设置委托类（设置父类）
           enhancer.setSuperclass(clazz);
           // 设置方法拦截器
           enhancer.setCallback(new DebugMethodInterceptor());
           // 创建代理类
           return enhancer.create();
       }
   }	
   ```

## **JDK 动态代理和 CGLIB 动态代理对比**

* 实现方式： JDK 动态代理基于**<u>公共接口</u>**实现，因此只能增强接口中现有的方法；CGLIB 动态代理基于**<u>继承委托类</u>**实现，可以增强除了被`final`修饰的任何类。
* 效率：JDK 动态代理效率较高，CGLIB 动态代理效率较低。

## 参考

* [从 头捋了一遍 Java 代理机制，收获颇丰！ 知乎](https://zhuanlan.zhihu.com/p/354402149)