[TOC]

## Overview
应用层通过不同的应用层协议为不同的应用提供通信服务。
常用协议：

* [HTTP](#HTTP)
* [HTTPS](#HTTPS)
* [DNS](#DNS)

###  用户输入网址到显示对应页面的全过程

![Alt Text](https://res.cloudinary.com/practicaldev/image/fetch/s--GY9Fa-eL--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/lya7b81ow94pniln3aif.jpg)

1. DNS 解析:DNS服务器进行域名映射，将域名解析成 IP 地址。
2. TCP 连接：客户端与服务端建立TCP连接。
3. HTTP 请求：客户端通过Socket向目标IP地址的服务器发送相应的[HTTP](#HTTP)或[HTTPS](#HTTPS)连接请求。
4. HTTP 响应：服务端通过Socket解析该请求，并从存储器检索出对象，然后将该对象封装进响应报文，返回指定的URL数据；如果发出错误则返回错误信息；如果设定重定向，则重定向到新的URL地址。
5. 解析渲染页面：客户端下载数据，解析HTML源文件，并分析页面中的超链接，显示在当前页面。

### URL

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210502020549.png)

HTTP 使用 URL（ Uniform Resource Locator，统一资源定位符）来定位资源，它是 URI（Uniform Resource Identifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。

## HTTP
Hyper Text Transfer Protocol(超文本传输协议）
提供HTML(超文本标记语言)的发送和接收方法，一般基于[传输层](%E4%BC%A0%E8%BE%93%E5%B1%82.md)/[网络层](%E7%BD%91%E7%BB%9C%E5%B1%82.md)通信，使用B/S架构。

### 特点

* 支持C/S架构。
* 简单快速：客户向服务器请求服务时，只需传送<u>请求方法</u>和<u>路径</u>。由于HTTP协议简单，使得其服务器的程序规模小，因而通信速度很快。
* 灵活：允许传输任意类型的数据对象。正在传输的对象类型由 `Content-Type`加以标记。
* **无连接**：无连接的含义是限制每次连接只处理一个请求。<u>服务器处理完客户的请求，并收到客户的应答后，即断开连接</u>。采用这种方式可以节省传输时间。
* **无状态**：无状态是指协议对于**事务处理没有记忆能力**。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### 组成
* 请求报文
	
	```http
	GET http://www.example.com/ HTTP/1.1
	Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
	Accept-Encoding: gzip, deflate
	Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
	Cache-Control: max-age=0
	Host: www.example.com
	If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
	If-None-Match: "3147526947+gzip"
	Proxy-Connection: keep-alive
	Upgrade-Insecure-Requests: 1
	User-Agent: Mozilla/5.0 xxx
	
	param1=1&param2=2
	```
	
	1. 请求行：包含请求方法、URL、协议版本
	2. 请求头：每个首部都有一个首部名称，以及对应的值
	3. 请求正文：请求的内容主体
	
	
	
* 响应报文
	
	```http
	HTTP/1.1 200 OK
	Age: 529651
	Cache-Control: max-age=604800
	Connection: keep-alive
	Content-Encoding: gzip
	Content-Length: 648
	Content-Type: text/html; charset=UTF-8
	Date: Mon, 02 Nov 2020 17:53:39 GMT
	Etag: "3147526947+ident+gzip"
	Expires: Mon, 09 Nov 2020 17:53:39 GMT
	Keep-Alive: timeout=4
	Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
	Proxy-Connection: keep-alive
	Server: ECS (sjc/16DF)
	Vary: Accept-Encoding
	X-Cache: HIT
	
	<!doctype html>
	<html>
	<head>
	    <title>Example Domain</title>
		// 省略... 
	</body>
	</html>
	```
	
	1. 状态行：含协议版本、状态码以及描述
	2. 响应头
	3. 响应主体
#### 消息头

HTTP 消息头分为通用标头、实体标头、请求标头和响应标头四种类型。

* General headers（通用头）: 同时适用于请求和响应消息，但与最终消息主体中传输的数据无关的消息头。
* Request headers（请求头）: 包含更多有关要获取的资源或客户端本身信息的消息头。
* Response headers（响应头）: 包含有关响应的补充信息。
* Entity headers（实体头）: 包含有关实体主体的更多信息。

* 通用头
  * Date：创建报文的日期时间
  * Cache-Control：控制缓存行为
  * Connection：表示是否为持久性连接。 `keep-alive`表示持久性连接，`close`表示非持久性连接
  * Last-Modified：表示资源的最后修改时间
* 实体头
  * Transfer-Encoding：指定报文主体的传输编码方式
  * Content-Length：说明实体主体的大小，以字节为单位
  * Content-Encoding：说明压缩实体的编码方法
  * Content-Language：说明实体主体的自然语言
  * Content-Range：说明实体主体的位置范围
  * ContentType：说明实体主体的类型
  * Allow：说明资源科支持的HTTP方法
* 请求头
  * Accept：表示客户端能接受的消息类型
  * Accept-Charset：表示客户端能接受的字符集
  * Accept-Encoding：表示客户端希望服务端返回的内容编码
  * Accpet-Language：表示客户端需要服务端返回的自然语言
  * Host：指定虚拟主机的服务器域名
  * IF-MATCH、If-Modified-Since、If-None-Match、If-Range：表示条件请求
* 响应头
  * Keep-Alive：指定TCP存活时间
  * Server：说明服务器的软件信息
  * Set-Cookie：说明 cookie信息

### 常见请求方法
* GET：用于**从指定资源请求数据**。
* HEAD：与GET几乎相同，但没**有响应主体**。可用于在实际发出GET请求之前检查GET请求的返回内容。
* POST：在服务器**新建**资源，数据被包含在请求体中，**不是幂等**的。
* PUT：在服务器将资源**替换**成指定资源，是**幂等**的。
* DELETE：删除指定资源。

其他方法：

* OPTION：描述支持指定资源的方法。
* CONNECTION：建立一个到由目标资源标识的服务器的隧道。
* TRACE：沿着到目标资源的路径执行一个消息环回测试。

一个HTTP方法是**幂等**的，指的是同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。在正确实现的条件下， [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) ， [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD) ， [`PUT`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/PUT) 和 [`DELETE`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/DELETE) 等方法都是**幂等**的，而 [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST) 方法不是。所有的 [safe](https://developer.mozilla.org/zh-CN/docs/Glossary/safe) 方法也都是幂等的。

#### GET和POST的区别

* **重复调用**：GET是**幂等**的，多次调用相同的GET请求将始终产生相同的结果；POST不是**幂等**的，因此重复调用POST方法将导致相同资源被多次创建。

* **用途**：GET用于从指定资源请求数据；POST用于将数据发送到服务器以**创建**资源。
* **存放位置**：GET是直接添加到URL后面的，可以直接在URL中看到内容；POST是放在报文内部的，用户无法直接看到（可以通过一些抓包工具查看），因此POST相对比GET更安全。
* **长度**：GET有长度限制（因为放在URL后面，URL根据不同的浏览器有不同长度限制）；POST没有长度限制。
* **参数限制**：GET只支持**URL编码**和**ASCII字符**的数据类型；而POST没有没有限制。
* **缓存**：GET可以被缓存，POST不会被缓存。

#### PUT和POST的区别

* **用途**：PUT用于**更新/新建**资源；POST用于**创建**资源。

* **重复调用**：PUT是**幂等**的，多次调用相同的PUT请求只会覆盖掉原来的资源；POST不是**幂等**的，因此重复调用POST方法将导致相同资源被多次创建。
* **URI**：PUT的资源的URI由客户端指定；POST的资源的URI由服务端指定。
* **缓存**：PUT可以被缓存，POST不会被缓存。

> 如何重试 POST 请求？
>
> 在 POST 请求中隐藏一个唯一的 token，服务端在处理请求后把 token 存入数据库，如果这个 token 之前遇到过，服务端就认为这是重复的 POST 请求，不再处理。

### 响应状态码
HTTP的响应状态码由3个10进制数组成，第一个数有分类的作用。
| S.N. | Code and Description                                         |
| ---- | ------------------------------------------------------------ |
| 1    | **1xx: Informational**It means the request has been received and the process is continuing. |
| 2    | **2xx: Success**It means the action was successfully received, understood, and accepted. |
| 3    | **3xx: Redirection**It means further action must be taken in order to complete the request. |
| 4    | **4xx: Client Error**It means the request contains incorrect syntax or cannot be fulfilled. |
| 5    | **5xx: Server Error**It means the server failed to fulfill an apparently valid request. |

***
#### 常见状态码

* 100 Continue： 一切正常 可以**继续发送**（在post方法中，可以先发送请求行，待服务端返回100后再继续发送请求头部和请求体）

-   200 OK： 客户端**请求成功**
-   204 No content：请求正常处理，但是**没有数据返回**
-   206 Partial Content：返回**指定范围**的数据
-   301 Moved Permanently： 资源被**永久转移到**其它URL  
-   302 Found：资源被**暂时转移**到其它URL    
-   400 Bad Request：服务器无法识别客户端请求，可能是客户端的请求有语法错误
-   401 Unauthorized: 请求**未经授权**，如请求页面需要用户名和密码
-   403 Forbidden：客户端**禁止访问**请求页面
-   404 Not Found：服务器**无法找到对应资源**
-   405 Method Not Allowed：客户端的**请求方法被禁止**
-   500 Internal Server Error：服务端**内部错误**  
-   501 Not Implemented：服务器**不支持**客户端所需的**功能**
-   502 Bad Gateway：服务器收到上游服务器的无效响应
-   503 Service Unavailable：服务器暂时超载或正在进行停机维护
-   504 Gateway Timeout：网关超时
### 长连接和短连接
**长连接**：客户端发起第一次请求建立**TCP连接**之后的一段时间之内，不需要再次建立**TCP连接**
**短连接**：每次传输对象都需要建立一次**TCP连接**。
在 HTTP/1.1 及之后的版本中默认使用持久连接。
<u>注意：持久连接需要配置正确的keep-alive timeout参数，否则可能导致资源被长时间无效占用。</u>

**流水线**：在持久连接的基础上，连续发出多次请求，而不用等待响应返回。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

### **如何保存用户状态**
HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。常有以下两种解决方法：

#### Cookie

cookie：服务器在客户端存放的小块数据，并随每一个请求发送至同一服务器，用于判断两个请求是否来自同一个浏览器。是HTTP协议无状态的一种补充和改良。

The [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:

```http
Set-Cookie: <cookie-name>=<cookie-value>
```

1. 服务器在**响应头部**告知客户端保存 Cookie 信息。

```http
HTTP/2.0 200 OK
Content-Type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

[page content]
```

2. 在此之后，客户端（浏览器）每次对服务器的请求都会带上Cookies信息。

```http
GET /sample_page.html HTTP/2.0
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
```

#### Session

在客户端第一次向服务器发送HTTP请求时，服务器将会话状态保存起来（例如放在Redis中），然后分配一个**会话标识**（SessionId）给客户端。

以后每次浏览器发送请求时都会带上**Cookie**中的**会话标识**到服务器，服务器根据请求头中的会话标识，把之前**存储在服务器端的状态信息**与会话联系起来，实现会话保持。

> 若客户端禁止使用Cookies，则不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。

缺点：Session不能在不同服务器共享，如果做了负载均衡，客户端访问不同的服务器时会导致Seesion 失效。

#### Cookie和Session的区别

* **存放位置**：cookie是存放在**客户端**，用于记录用户信息的，比如自动填充用户名和密码；session是存放在**服务端**的，用于记录用户的状态，比如购物车的实现。
* **安全性**：cookie由于存放在客户端，容易被恶意查看，所以安全性不高；而session存放于服务器中，所以安全性较高。
* **容量**：单个cookie保存数据不能超过4k；session没有对存储数据量的限制，但同时也会造成服务器的存储负担。

### HTTP的发展历程

#### HTTP/1.1的改进

1. **连接**：默认是**长连接**，支持**流水线**， 支持**同时打开多个 TCP 连接** 。
2. **状态码** HTTP1.1新增24个错误状态响应码，如410Gone指的是服务器上某个资源被永久删除。
3. **节约带宽**：支持**断点续传**，在请求头中引入了**range头域**，允许只请求资源的某个部分，返回状态码是**206（partial content）**
4. **Host 请求头**：为了支持虚拟主机，添加了 Host 请求头，**请求消息和响应消息中应声明这个字段**，若请求消息中缺少该字段时服务端会返回404 状态码。
5. **缓存策略**：引进了更多可供选择的缓存头来控制缓存策略。

#### HTTP/2.0的改进

1.**头部压缩** ：客户端和服务器同时**维护和更新一个包含之前见过的首部字段表**，从而避免了重复传输。并且，HTTP/2.0 使用 **Huffman 编码**对头部字段进行压缩。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/_u4E0B_u8F7D.png)

2.**二进制格式**：HTTP/2.0 将所有传输的信息分成**二进制格式**的HEADERS （头部）帧和 DATA （数据）帧。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/86e6a91d-a285-447a-9345-c5484b8d0c47.png)

3.**多路复用** ：在通信过程中只有一个 TCP 连接存在，它承载了任意数量的**双向数据流**，用于承载由**帧**组成的**消息**。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/af198da1-2480-4043-b07f-a3b91a88b815.png)

>  * 每个数据流中都有一个唯一**标识符**和可选的**优先级**信息。**标识符**可以用来标识HTTP请求，优先级可以一定程度上解决关键请求被阻塞的问题。
>  * 消息（Message）是与逻辑请求或响应对应的完整的一系列帧。
>  * 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。

4.**服务器推送**：在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png)

## HTTPS

Hyper Text Transfer Protocol over Secure Socket Layer

### HTTPS和HTTP的区别

* HTTPS相对HTTP多了一个[SSL](HTTPS.md#SSL)
  * HTTPS传输过程是加密的
  * 服务器需要到CA申请证书
  * **响应较慢**，需要经过一个SSL/TLS
* 端口号是443（HTTP端口号是80）
### SSL/TLS

SSL(secure sockets layer)/TLS(Transport Layer Security): 用于在联网计算机之间建立经过身份验证和加密链接的协议。

SSL握手过程：

1. 客户端向服务端发起**Client Hello**，请求内容包括支持的**SSL版本**，**加密组件**及**客户端随机字符串**等信息。

2. 服务端回应客户端**Server Hello**，回应内容包括服务端选择**的SSL版本**和**加密组件**，**服务端随机字符串**以及**带有公钥的CA证书**等信息。

   > 如果该验证过程属于双向验证，服务端还会想客户端请求客户端的CA证书。

3. 客户端从 CA（证书颁发机构）验证服务器的 SSL 证书并对服务器进行身份验证。如果身份验证失败，则客户端拒绝 SSL 连接并抛出异常。如果身份验证成功，则继续执行接下来的步骤。

4. 客户端生成字符串`pre-master-secret`，并使用CA证书中的公钥对其进行加密，然后将其发送给服务端。

5. 服务端使用公钥解密，得到`pre-master secret`。

6. 现在服务端和客户端使用之前协商好的加密组件将客户端随机字符串、服务端随机字符串以及`pre-master secret`结合在一起生成`master secret`。

7. 双方互相告知以后的会话使用`master secret`加密以及验证自身`master secret`的正确性，成功之后握手结束。

### 如何验证CA证书

1. 证书是否是**信任**的**有效**证书。

   * **信任**：证书的颁发机构是**信任根证书**或**信任根的二级证书**机构。
   * **有效**：证书在**有效期**内并且**没有被吊销**。

2. 对方是不是上述证书的合法持有者，即对方是否拥有证书的私钥。

   

### 中间人攻击

黑客为了绕过HTTPS，阻止用户和使用HTTPS请求的网站之间建立SSL连接，使用户和攻击者控制的代理服务器之间使用了未加密的HTTP通信。

整体流程：

![preview](https://pic1.zhimg.com/3ec57b331603a05a8ce87e8084c73b94_r.jpg)

修改DNS配置从而劫持用户请求，将HTTPS链接全部重写为HTTP链接，使用HTTP与受害者客户端链接，同时与合法的服务器建立HTTPS，因此受害者客户端与合法服务端之间的通信请求全部都经过代理转发。

解决方法：确保DNS没有被劫持。

## DNS
Domain Name System，域名系统
作用：用于将域名转换成IP地址，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。

### 层次结构

![image-20210929011129153](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210929181158.png)
树状结构，从上到下依次为**根域名**服务器、**顶级域名**服务器和**权威域名**服务器等。

注意：本地local DNS（也叫递归DNS）一般不包含在层次结构中，且不会配置任何数据，其数据均来自权威DNS的查询缓存。

### 解析过程

![how-route-53-routes-traffic](https://d1.awsstatic.com/Route53/how-route-53-routes-traffic.8d313c7da075c3c7303aaef32e89b5d0b7885e7c.png)

1. 客户端根据要查询的域名向本地DNS发起解析请求。
2. 若本地DNS缓存中有记录，则返回对应的IP；否则本地DNS 向**DNS层次结构**中的域名服务器发起请求，域名服务器返回对应的IP地址或者本地DNS下一个应该查询的域名服务器。

> DNS涉及两种查询方式：递归查询和迭代查询。
>
> * 客户端向本地DNS查询的过程属于递归查询，即客户端只会向本地DNS发起一次查询，之后的查询都由本地DNS代理；
>
> * 本地DNS向DNS层次结构的域名服务器的查询则属于迭代查询。



## DHCP

**DHCP（动态主机配置协议）**：一种服务器服务，可为客户端动态分配或租用 IP 地址和相关 IP 信息。

### 过程

1. **DHCP DISCOVER**：客户端向DHCP服务器发送 **DHCP 发现报文**（`DHCP DISCOVER`） ，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 **UDP 广播通信**。<u>DHCP 客户端将该IP 数据报传递给链路层，链路层然后将帧**广播**到所有的网络中设备</u>。
2. **DHCP OFFER**：DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文**（`DHCP OFFER`） 向客户端做出响应。该报文仍然使用 IP 广播地址 (`255.255.255.255`)，该报文信息携带服务器提供**可租约的 IP 地址**、**子网掩码**、**默认网关**、**DNS 服务器**以及 **IP 地址租用期**等信息。
3. **DHCP REQUEST**：客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 DHCP 请求报文（`DHCP REQUEST`)进行响应，回显配置的参数。
4.  **DHCP ACK**：服务端用 `DHCP ACK` 报文响应客户端，应答所要求的参数。

### DHCP 中继代理

由于DHCP使用的UDP的广播通信，因此只能在一个局域网内传播，因为路由器不会转发广播包。

解决方式：使用<u>DHCP 中继代理</u>。

![image-20210929160011407](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210929160014.png)

1. DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以**单播**的形式发给 DHCP 服务器。
2. 服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包广播给DHCP 客户端 。



## 参考

* [经典面试题：从 URL 输入到页面展现到底发生什么？](https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/)
* [DNS原理及解析过程详解](https://zhuanlan.zhihu.com/p/88260838)
* [What is SSL, TLS? And how this encryption protocol works](https://www.csoonline.com/article/3246212/what-is-ssl-tls-and-how-this-encryption-protocol-works.html)
* [浅谈SSL/TLS工作原理](https://zhuanlan.zhihu.com/p/36981565)
* [十分钟搞懂HTTP和HTTPS协议？](https://zhuanlan.zhihu.com/p/72616216)
* [GET 和 POST 的区别]( https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ez30qs/)
* [Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/eg0dl5/)

* [HTTP Methods GET vs POST - W3Schools](https://www.w3schools.com/tags/ref_httpmethods.asp)
* [HTTP PUT 与 POST 的区别](https://bitmingw.com/2018/04/16/http-put-vs-post/)