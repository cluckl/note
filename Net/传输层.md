

# 传输层

[TOC]



## Overview

传输层为提供进程之间的**端到端**的**逻辑通信**服务。

### Port
Port(端口)：**区分每个[进程](../OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B)的标识符**，1个端口号使用16位无符号整数（unsigned integer）来表示。[TCP](#TCP)和[UDP](#UDP)是互相独立的，因此TCP和UDP都各拥有65535个端口。
* 1--1023 系统保留，只能由root用户使用。
* 1024---4999 由客户端进程占有
* 5000---65535 由服务器端进程自由分配

在[UDP](#UDP)中，源端口号可以选择要不要填上，如果设为0，则代表没有源端口号。

### TSAP
TSAP(Transport Service Access Point) : 传输服务访问点,也称为传输层地址。
TSAP = [IP](网络层.md#IP) + [Port](#Port)
![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143032.png)

### Socket
**套接字（Socket）是为了使应用程序能够方便地使用协议栈软件进行通信的一种方法。**
![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143033.png)
套接字上联==应用进程==，下联==网络协议栈==，是[进程](../OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B)通过网络协议栈进行通信的接口。 
结构：

* 相关描述：{协议，本地[IP](网络层.md#IP)地址，本地端口[Port](#Port)}
* 相关描述：{协议，本地地址，本地端口，**远程地址，远程端口**}
### 分类
* **Stream** Socket
	* 面向连接、可靠
	* 按顺序接收
	* **字节流**
* **Datagram** Socket
	* 无连接
	* **数据报**
	* 接收顺序不固定
* Raw Socket
	* 用于检验新的协议的实现
	* 允许对较低层次的协议

## UDP
UDP(User Datagram Protocol)：用户数据报协议，只提供了**差错检测**（可选）的功能，因此相对[TCP](#TCP)**速度更快**。

### 特点

* PDU:**数据报**(datagrams)

* 不需要连接，适用于**广播通信**
* 面向**消息**（message oriented）
* 不可靠，无拥塞控制，流量控制

<img src="https://book.systemsapproach.org/_images/f05-02-9780123850591.png" alt="../_images/f05-02-9780123850591.png" style="zoom:40%;" align="left"/>

### UDP报头

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143036.png)


UDP为了能够计算校验和，必须加上伪头部。

### connect和bind函数
* bind：发送端调用 bind 函数时，就会将这个套接字指定一个端口，避免内核执行该操作，提高性能
* connect：记录IP及Port。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。

## TCP
TCP(Transmission Control Procotol)：传输控制协议。

### 特点

* PDU:**数据段(Segment)**
* 需要连接，只适用于一对一单播
* 面向字节流（byte steam oriented）
* ==可靠性==
  * 流量控制——滑动窗口
  * [拥塞控制](%E4%BC%A0%E8%BE%93%E5%B1%82.md#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
  * 序列号及应答机制——确保数据能无重复地达到
  * 校验和——确保数据在传输的过程中没有发生变化

### 结构

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143034.png" style="zoom:80%;" />

* PSH：指示接收端应用层**<u>立即</u>**从缓冲区取走数据
* RST：表示要求对方**<u>重新建立连接</u>**
* urgent pointer：表示最后一个紧急数据段的下一个序号的偏移量

#### Checksum校验和

TCP checksum includes the:

1. Pseudo IP header 
2. TCP header
3. TCP body

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20200329123054/TCP21.png" alt="img" style="zoom: 80%;" align="left"/>

计算过程

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20200329123142/TCP11.png" alt="img" style="zoom:67%;" align="left"/>

1. 将伪头部、TCP头部（Checksum部分为0）、TCP数据分为16位的字。（如果总长度为奇数个字节，则在最后增添一个位都为0的字节）
   将全部字相加并对计算结果取反作为TCP的校验和
2. 检验过程：将伪头部、TCP头部、TCP数据分成的16位的字的原码相加，若结果全为1说明检测成功。

检验过程：将伪首部、TCP报头、TCP数据分成的16位的字的**原码相加**，若结果全为1说明检测成功。

> *Why IP header error checking two times is needed ?* 
>
> The IP header is checked two times the first time in the Transport layer and second time in Network Layer. The IP header is checked two times because double checking ensures that any error in the IP header can be detected with proper accuracy.

#### TCP分段

TCP分段的原因：

1. 一定程度上减少IP分片
2. 发生重传时只重传分段后的数据

---

TCP分段后不能避免IP分片：整个传输链路中可能还会**<u>有其他MTU可能小于发送端MTU的网络层设备</u>**。

解决方式：

在TCP正式通信之前获取路径**<u>MTU(Path MTU)</u>**：

1. 设置IP首部的标志位的第二位**DF(Don’t Fragment)**为1，禁止IP分片。
2. **<u>利用ICMP获取Path MTU</u>**，直到IP数据包成功传送到目的主机。



### 连接过程
TCP协议的运行可划分为三个阶段：
1. [连接创建](#连接创建)(connection establishment)
2. 数据传送（data transfer）
3. [连接释放](#连接释放)（connection termination）

#### 连接创建⭐

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143035.png" style="zoom:67%;" align="left"/>

TCP用==三次握手==（或称三路握手，three-way handshake）过程创建一个连接。


1. 客户端向服务器端发送一个SYN数据段，其以随机数x作为序列号，同时客户端从关闭阶段进入同步发送阶段。
2. 服务端收到一个合法的SYN数据段后，把其放入SYN队列中；回送一个SYN/ACK数据段，其以随机数y作为序列号，x+1为确认号，同时服务端从监听阶段进入同步接收阶段。
3. 客户端收到SYN/ACK数据段后，发送一个序列号为x+1，确认号为y+1的ACK数据段，同时客户端进入连接建立阶段，而服务端在收到该数据段后也进入连接建立阶段。

> 在Linux系统中，会维护两个队列：
>
> * 半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态
> * 全连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态

意外情况：

* 第一次/第三次握手丢包：根据超时重传机制，客户端或者服务端在发出数据段后，当重传计时器计时结束后，会再次重传，若重传超过一定的次数则会放弃连接。
* 第二次握手丢包：客户端 SYN 数据段会发生超时重传，服务端 SYN/ACK 也会发生超时重传。
* 全连接队列溢出：当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃

* SYN泛洪攻击：半连接队列存储过多的SYN数据段。解决方法：
  * 增大半连接队列的大小
  * 减少 SYN+ACK 重传次数
  * 开启 tcp_syncookies 功能：服务器根据当前状态计算出一个值，放在发出的 SYN/ACK 数据段中发出，当客户端返回 ACK 数据段时，取出该值验证，如果合法，就认为TCP连接建立成功

#### 数据传送

TCP is a byte-oriented protocol, which means that the sender writes bytes into a TCP connection and the receiver reads bytes out of the TCP connection. Although “<u>byte stream</u>” describes the service TCP o<u>ffers to application processes</u>, TCP does not, itself, transmit individual bytes over the Internet. Instead, TCP on the source host buffers enough bytes from the sending process to fill a reasonably sized packet and then sends this packet to its peer on the destination host. TCP on the destination host then empties the contents of the packet into a receive buffer, and the receiving process reads from this buffer at its leisure. 

<img src="https://book.systemsapproach.org/_images/f05-03-9780123850591.png" alt="../_images/f05-03-9780123850591.png" style="zoom:50%;" align="Left"/>

#### 连接释放⭐
<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424143037.png" style="zoom: 67%;" align="left"/>

1. 客户端发送FIN包给服务器端，结束 ESTABLISHED 阶段并进入 FIN-WAIT-1 阶段
2. 服务器端收到客户端的FIN包后发送ACK数据段给客户端，结束 ESTABLISHED 阶段并进入CLOSE-WAIT 阶段，客户端收到ACK数据段后进入FIN-WAIT-2 阶段
4. 服务器端将数据传送完毕后发送ACK/FIN数据段给客户端，结束CLOSE-WAIT阶段并进入 LAST-ACK 阶段
4. 客户端收到ACK/SYN数据段后进入TIME-WAIT 阶段并发送ACK数据段给服务器端，服务端在收到该数据段后进入CLOSE阶段，而

   客户端在 TIME-WAIT 阶段等待 **2 MSL(Maximum Segment Lifetime)**也进入 CLOSED 阶段。
   > 客户端等待 2 MSL的原因：
   > * 保证没有数据包滞留
   > *  确保客户端发的ACK包被服务器端收到（如果服务器端没有收到将认为自己发送的ACK/SYN包没有收到而再次发送）

### 计时器
TCP主要有以下4种计时器
* 重传计时器：当发送方发送的数据包后一段时间内没有收到对方发送的ACK包则重发该数据包。
* 保活计时器：当接收方没有收到对方的数据包一段时间后，将发送一个探测包以检测对方是否正常在线。
* 坚持计时器：当发送方收到接收方的滑动窗口为0的数据包后将停止发送数据包，等待一段时间后将发送一个探测包，避免死锁发生。
* 时间等待计时器：在四次挥手中客户端收到ACK/FIN包后开始计时。

除上述四种计时器外，还有FIN_WAIT_2 计时器、延迟应答计时器等等。

### ==流量控制==

TCP主要通过**滑动窗口**实现流量控制，即接收方通过TCP 数据段中的**窗口字段**控制发送方的发送速率。

<img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" style="zoom:67%;" />

窗口：缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口：

发送窗口：窗口内的字节由**已发送但未受到确认**的字节和**允许发生但还没发送**的字节组成。在不考虑窗口大小变化的情况下，每当窗口左边第一个字节收到确认时，窗口就向右滑动一个字节。

接收窗口：窗口内的字节由**未按序到达**的字节和**允许接收**的字节组成。<u>接收窗口只会对**最后一个按序到达**的字节进行确认</u>。

### ==拥塞控制==

发送方通过设置**拥塞窗口**的大小控制发出的字节数，以在**一定程度上**避免网络拥塞出现。
<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210502153307.png" alt="image-20210502153307772" style="zoom: 67%;" />

1. **慢启动**：设置拥塞窗口值（cwnd）为1个MSS(Maximum Segment Size)，发送方每收到一个ACK包cwnd加1，因此每个RTT(round-trip time)cwnd加倍，直到cwnd达到慢启动阈值(ssthresh, slow start threshold)或触发重传机制。
2. **拥塞避免**：接收方每经过一个RTT，cwnd加1(**加法增大**)，直到发送方触发重传机制。

这里的重传机制包括两种：

* **<u>超时重传机制</u>**：慢启动阈值设为之前拥塞窗口值的一半，拥塞窗口值降为初始值，重新进入慢启动阶段。
* <u>**快速重传机制**</u>：触发<u>**快速恢复机制**(Reno)</u>：慢启动阈值设为之前拥塞窗口值的一半(**乘法减小**)，拥塞窗口值设置为新的慢启动阈值，即跳过慢启动阶段，直接进入拥塞控制阶段。

    >考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时**不执行慢开始**算法。
### 快速重传机制
**快速重传机制（Fast retransmit）**：接收方每次接收到数据段时都应该对**最后一个已收到的有序数据段**进行确认。

快速重传机制：如果在重传计时器超时之前，接收方接收到连续的**3个重复冗余ACK（<u>即一共接收过4次相同确认号的ACK</u>）**，发送端便会重传**下一个**数据段，以减少**端到端的时延**。

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210502153900.png" alt="image-20210502153900934" style="zoom:50%;" align="left"/>

>为什么是3个冗余ACK？
>
>接收端收到比期望序号大的数据段时，该数据段不一定已经丢失，也有可能在将来的某个时间到达。

### 粘包问题⭐

<u>严格来说，TCP是面向字节流的协议，不存在“粘包问题”。</u>
粘包有两种含义

1. 由于发送方采用Nagle算法，将多个小数据包放在一起发送出去。
2. 接收方的[应用层](%E5%BA%94%E7%94%A8%E5%B1%82.md)来不及处理数据，接收方又收到了新的数据包。

解决方法：应用层协议自己设计**消息的边界**，即消息帧（Message Framing）：

* 基于长度
* 基于终结符（Delimiter）

> HTTP使用`Content-Length` 头表示 HTTP 消息的负载大小，若HTTP 使用块传输（Chunked Transfer）机制，则使用负载大小为 0 的 HTTP 消息作为终结符表示消息的边界。

## TCP和UDP的区别

|                    | TCP                                  | UDP                          |
| ------------------ | ------------------------------------ | ---------------------------- |
| PDU                | 数据段(Segment)                      | 数据报(datagrams)            |
| 是否需要连接       | 需要连接，只适用于一对一单播         | 不需要连接，适用于广播通信   |
| 与应用层的交互形式 | 面向字节流（byte steam oriented）    | 面向消息（message oriented） |
| 可靠性             | 流量控制、拥塞控制、重传机制、校验和 | 无法保证                     |
| 是否分段           | 根据MSS进行分段                      | 不分段                       |

# Reference
* [UDP 为什么是不可靠的？bind 和 connect 对于 UDP 的作用是什么](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/es7qwj/)
* [三次握手和四次挥手机制- Leetcode](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esegch/)
* [TCP第四次挥手为什么要等待2MSL-CSDN博客](https://blog.csdn.net/LF_2016/article/details/60468161)
* [TCP 协议中的定时器- Leetcode](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/esd47g/)
* [TCP使用的四种计时器_Sunnylunch-blog-CSDN博客](https://blog.csdn.net/LF_2016/article/details/60468100)
* [TCP拥塞控制- 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
* [TCP流量控制、拥塞控制- 知乎](https://zhuanlan.zhihu.com/p/37379780)
* [Calculation of TCP Checksum - GeeksforGeeks](https://www.geeksforgeeks.org/calculation-of-tcp-checksum/)
* [5.2 Reliable Byte Stream (TCP)](https://book.systemsapproach.org/e2e/tcp.html)
* [为什么TCP 协议有粘包问题- 面向信仰编程](https://draveness.me/whys-the-design-tcp-message-frame/)
* [TCP分段与IP分片的区别与联系 - 腾讯云](https://cloud.tencent.com/developer/article/1173790)



