# 基本操作

## 二叉树的遍历

非递归遍历本质是**模拟栈的调用**。

### 前序遍历

```python
def preorderTraversal(root: TreeNode):
    stack = []
    cur = root

    while stack or cur:
        while cur:
            # visit
            stack.append(cur.right)
            cur = cur.left

        cur = stack.pop()
```

### 中序遍历

```python
def inorderTraversal(root: TreeNode):
    stack = []
    cur = root

    while stack or cur:
        while cur:
            stack.append(cur)
            cur = cur.left

        cur = stack.pop()
        #visit
        cur = cur.right
```

### 后序遍历

```python
def postorderTraversal(root: TreeNode):
    stack = []
    cur = root
    before = None
    
    while stack or cur:
        while cur:
            stack.append(cur)
            cur = cur.left
        
        cur = stack[-1]

        if not cur.right or before == cur.right:
            cur = None
            before = stack.pop()

            # visit
        else:
            cur = cur.right
```

# 二叉搜索树

1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值
3. 任意节点的左、右子树也分别为二叉查找树

## 红黑树

![An example of a red-black tree](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/450px-Red-black_tree_example.svg.png)

红黑树是每个节点都**<u>带有颜色属性</u>**的二叉搜索树，颜色为红色或黑色，可以**<u>缓解</u>**普通的二叉搜索树在极端情况下退化成链表导致查找效率降低的问题。红黑树必须具备以下性质：

1. <u>**根节点**</u>和<u>**叶子节点**</u>是黑色，且叶子节点是空节点(NIL)
2. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
3. 从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点。

这些性质确保了红黑树的关键特性：**<u>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</u>**。

当插入新节点时，通过**<u>换色</u>**、**<u>左旋</u>**和**<u>右旋</u>**保持上述性质。

### 插入操作

#### 左旋

![img](https://pic3.zhimg.com/v2-312472251d63f7d3cd0b8fc2deed3c96_b.webp)

#### 右旋

![img](https://pic4.zhimg.com/v2-665f59c694f38e71c8c7fddb7a4cb183_b.webp)

## B&B+树

* h值都保存在叶子节点，且都按顺序存储
* 每一个叶子节点都包含指向下一个叶子节点的指针
* 每一个叶子页到根的距离相同


### B+树和B树的区别

* B 树一个节点里存的是数据，而 B+树存储的是索引（地址），所以单节点能够存储大量索引，减少磁盘IO
* B+树的叶子节点是数据阶段用了一个链表串联起来，便于范围查找。
* B+树的叶子节点才是真正存储数据的地方。