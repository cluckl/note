[TOC]

# 事务

事务（Transaction）是**并发控制**的基本单位。所谓的事务，即**一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位**。
## ACID
* Atomicity（原子性）：一个事务中的所有操作，要么全做，要么不做，不会结束在中间某个环节。
* Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
* Isolation（隔离性）：多个事务之间不会互相干扰。
* Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

<u>AID的主要目的都是为了维护C(**一致性**)。必须要实现AID三大特性，才有可能实现一致性。</u>

### 如何保证一致性

* 数据库层面：通过原子性、隔离性、持久性保证一致性。
* 应用层面：实现有效的代码。

### 如何保证原子性

利用**undo log**日志文件，当事务需要回滚时，能够撤销所有已经成功执行的语句。

### 如何保证隔离性

实现相应的[事务隔离级别](事务#事务隔离级别)。
### 如何保证持久性

当数据库崩溃重启后，利用**redo log**日志，重演所有已经执行成功但**尚未写入磁盘**的操作。
## InnoDB的锁

Innodb中锁都是**作用在索引**上面。

### Record Locks

记录锁(Record Locks)：锁定一个记录（record）上的**索引**，可以防止插入、删除或更新操作。

### Gap Locks

间隙锁(Gap Locks)：锁定索引之间的间隙（gap），防止其他事务在间隙进行`insert`操作。

* 对于使用**唯一索引**的**单列**，不会触发间隙锁。例如`SELECT * FROM child WHERE id = 100;`，如果该`id`列具有唯一索引，则仅使用行锁锁定;如果`id`未建立索引或具有非唯一索引，则该语句会锁定前面的间隙。
* 间隙锁可以被禁用，如使用RC的隔离级别。
* 间隙锁可以共存，即使在相同的间隙内，两个事务也可以同时使用间隙锁。

### Next-Key Locks

临键锁(Next-Key Locks)：结合了**记录锁**和**间隙锁**，不仅锁定一个记录上的索引，也锁定索引之间的间隙。

### Shared and Exclusive Locks

**共享锁(Shared Locks, S)**: 一个[事务](事务.md)为数据加上S锁后直到该锁被释放期间，其他事务不能加X锁，只能加S锁。

**互斥锁(Exclusive Locks, X)**: 一个[事务](事务.md)为数据加上X锁后直到该锁被释放期间，其他事务不能为数据加任何类型的锁。

### Intention Locks

意向锁（Intention Locks）：属于表锁，分为**意向共享锁(IS)**和**意向排他锁(IX)**，可以避免在加[表锁](%E9%94%81.md#%E7%B2%92%E5%BA%A6%E9%94%81#%E8%A1%A8%E9%94%81)时需要遍历整个索引节点。意图锁的主要目的是表明表中有记录被锁定或打算锁定。

意向锁定协议如下：

- 一个事务在获得某个数据行对象的 `S` 锁之前，必须先获得表的 `IS` 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 `X` 锁之前，必须先获得表的 `IX` 锁。

<u>除了全表请求（例如，`LOCK TABLES ... WRITE|Read`）外，意图锁不会阻止任何内容。</u>

**Table-level lock** type compatibility is summarized in the following matrix.

|      | `X`      | `IX`       | `S`        | `IS`       |
| :--- | :------- | :--------- | :--------- | :--------- |
| `X`  | Conflict | Conflict   | Conflict   | Conflict   |
| `IX` | Conflict | Compatible | Conflict   | Compatible |
| `S`  | Conflict | Conflict   | Compatible | Compatible |
| `IS` | Conflict | Compatible | Compatible | Compatible |

### Insert Intention Locks

插入意向锁（Insert Intention Locks）：一种间隙锁，事务在进行插入操作之前，锁住临近索引的间隙。

两个事务进行insert操作时即使插入意向锁一样，如果行不冲突，则不会相互阻塞。

###  AUTO-INC Locks

自动增量锁(AUTO-INC Locks)：属于表锁，如果一个表使用自增主键（`AUTO_INCREMENT`），当一个事务进行insert操作时，将锁住整个表，防止其他事务进行insert操作，使得主键的id连续。

## 事务并发问题

* 更新异常（丢失修改）：已提交的事务的数据会被后提交的事务所提交或回滚的同一个数据覆盖。
* 脏读：一个事务的处理过程中读取了另一个事务未提交的数据。
* 不可重复读：一个事务对某个数据的两次查询返回的值不同，即不可重复。
* 幻读：一个事务对结果集的两次相同查询返回的结果集的数量不等。
## 事务隔离级别
MySQL默认使用Repeatable read，
事务的四种隔离级别从低到高分别是：

* Read uncommitted
* Read committed
* Repeatable read
* Serializable

| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| :--------------------------- | :----------------- | :------------------------------- | :------------------- |
| 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
| 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
| 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
| 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

### Read Uncommitted

未提交读（READ UNCOMMITTED）：事务中的修改，即使没有提交，对其它事务也是可见的。

实现：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁（**一级封锁协议**）。

特点：可以解决**更新异常**问题。

#### MySQL实现

* 类似Read Committed 的实现
* 普通的`select`不加锁，使用**当前读**，<u>可能读取到脏的数据</u>

### Read Committed

提交读（READ COMMITTED）：一个事务只能读取已经提交的事务所做的修改。

实现：读操作加[S锁](锁#读锁)，写操作加[X锁](锁#写锁)，读操作完毕释放S锁，写锁直到事务提交才释放（**二级封锁协议**）。
只能读取到已经提交的数据。

特点：可以解决**脏读**，允许不可重复读、幻读。

#### MySQL实现

* 普通的`select`不加锁，使用**快照读**
* locking read、`update`、`delete`

  * 命中聚簇索引

    *  在所有命中的聚簇索引上加 record lock

  * 命中二级索引

    * 在所有命中的二级索引和聚簇索引加 record lock

  * 没有命中索引

    * 锁住所有的聚簇索引，然后MySQL Server把不符合条件的锁当即释放掉
    

### Read Repeatable 

可重复读（REPEATABLE READ）：保证在同一个事务中重复读取同一数据的结果是一样的。MySQL中InnoDB默认的隔离级别。

实现：读操作加[读锁](锁#读锁)，写操作加[写锁](锁#写锁)，直到事务提交才释放读锁和写锁（**三级封锁协议**）。
特点：解决脏读和不可重复读，允许幻读。

#### MySQL实现

* 普通的`select`不加锁，使用快照读
* locking read、`update`、`delete`
  * 命中聚簇索引
    *  在所有命中的聚簇索引上加 record lock
    *  **若为非精确查询则还会在聚簇索引的所有间隙加gap lock**
  * 命中二级索引
    * 在所有命中的二级索引和聚簇索引加 record lock
    * **如果不是唯一索引或者不是精确查询，还会在命中的二级索引附近加 gap lock**
  * 没有命中索引
    * 对全表的所有聚簇索引加锁
    * **对全表聚簇索引的所有间隙加gap lock**

总结：<u>对于所有可能会命中多个列的情况，都会在命中索引加 record lock的基础上加 gap lock，以此防止幻读</u>。

### Serializable

可串行化（SERIALIZABLE）：事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

特点：有效避免幻读、不可重复读、脏读等问题。

#### MySQL实现

* 类似Read Repeatable 的实现
* **普通的`select`被InnoDB隐式转换成`select ... for update`**

## MVCC

MVCC：多版本并发控制(Multiversion concurrency control)
并发访问数据库时，对正在事务内处理的数据做多版本的管理。以达到用来避免写操作的堵塞，从而引发读操作的并发问题。
<u>可以减少锁的使用，大多数读操作都不用加锁。</u>
MVCC的核心是**自动增量的事务ID**和**历史快照（snapshot)**。

### 快照读和当前读

* 快照读(snapshot read)：读取数据时不是读取最新版本的数据，而是基于历史快照。快照读在DQL中可以不对数据加锁。是实现MVCC的一种方式。如`SELECT`等**DQL**。

* 当前读(current read)：读取的数据库最新的数据，需要对数据进行加锁。如`INSERT`、`UPDATE`和`DELETE`和locking reads (`SELECT with FOR UPDATE` or `FOR SHARE`)等**DML**。

### Innodb实现

#### 结构实现

Innodb实现MVCC的关键是**undo log、隐藏字段和Read View**。

* **undo log**
  * 当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 `undo log` 读取之前的版本数据。
  * 在MVCC中发挥作用的是<u>**update undo log**</u>， insert undo log只用于事务回滚。

* `InnoDB` 存储引擎为每个表中存在三个隐藏字段，其中有两个用于MVCC

  * **事务ID(DB_TRX_ID)**：用于记录**最近**操作该行的事务ID

  * **回滚指针(DB_ROLL_PTR)**：回滚指针，指向这条记录的上一个版本的undo log。通过`DB_ROLL_PTR`，新记录与undo log形成一个链表，遍历这个链表可以看到这条记录的历史版本。

* **Read view **保存活跃的事务集合、创建该Read view的事务等用于作可见性判断等信息。
  * `low_limit_id`：最大活跃事务ID+1，
  * `up_limit_id`:  最小活跃事务ID

___

#### 数据可见性算法

![image-20211002172246445](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20211002172248.png)

1. 记录对应的事务ID小于最小活跃事务ID(`DB_TRX_ID` < `up_limit_id`)或者等于当前事务的ID(`db_trx_id == createor_trx_id` )，说明该记录的最后一次修改在read view创建之前或者是当前事务修改的，可见
2. 记录对应的事务ID大于最大活跃事务ID(`DB_TRX_ID`  >=`low_limit_id`)，说明该数据是在当前read view 创建之后产生，不可见
3. **记录对应的事务ID不在活跃事务ID集合中(`DB_TRX_ID` ∉ Read view)，说明该记录的最后一次修改在read view创建之前，可见**
4. 若不符合上述情况，根据回滚指针获取上个版本的记录，重新进行上述判断。

经过上述匹配过程后可以获得可见的记录，此时判断该条记录的<u>`deleted_flag`，若`deleted_flag`为true说明该条记录被删除，不返回该记录；否则返回该记录。</u>

___

**Read view 生成时间**：
MVCC机制实际上只在Read Committed和Read Repeatable两种隔离级别中生效：

* Read Uncommitted：使用当前读
* Read Committed：**每次读取**记录都会创建一个read view
* Read Repeatable：事务开始后只在**第一次读取**（**first touch read**）记录时创建read view
* Serializable：普通的`select`被InnoDB隐式转换成`select ... for update`


## 参考
* [ACID - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/ACID)
* [一文带你理解脏读,幻读,不可重复读与mysql的锁,事务隔离机制](https://zhuanlan.zhihu.com/p/87178693)
* [数据库基础（四）Innodb MVCC实现原理](https://www.zhihu.com/people/bu-wang-chu-xin-57-36)
* [多版本并发控制- 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6)
* [Innodb中的事务隔离级别和锁的关系- 美团技术团队](https://tech.meituan.com/2014/08/20/innodb-lock.html)
* [深入理解数据库事务](https://www.zhihu.com/collection/651155971)
* [MySQL 8.0 Reference Manual :: 15.7.1 InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)
* [MySQL InnoDB MVCC深度分析- stevenczp - 博客园](https://www.cnblogs.com/stevenczp/p/8018986.html)

* [MySQL 是如何保证一致性、原子性和持久性的！ - 云+社区](https://cloud.tencent.com/developer/article/1600883)
