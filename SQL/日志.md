[TOC]

MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

`MySQL`数据库的**数据备份、主备、主主、主从**都离不开`binlog`，需要依靠`binlog`来同步数据，保证数据一致性。

## undo log

**undo log(回滚日志)**：

所有事务进行的修改都会先记录到回滚日志，然后再执行相关的操作，且回滚日志会先于数据持久化到磁盘上。

当遇到数据库突然宕机等情况，数据库再次启动时，够通过查询回滚日志来回滚将之前未完成的事务。

对于 update undo log来说，还可用于MVCC。

## redo log

* **`redo log`（重做日志）**：`InnoDB`存储引擎独有，提供崩溃恢复的能力。

  比如 `MySQL` 实例挂了或宕机了，重启时，`InnoDB`存储引擎会使用`redo log`恢复数据，保证数据的持久性与完整性。

  [![img](https://camo.githubusercontent.com/58dd9f814783e62a2104343b132f62a079e683405f40c06ea35a6abfe44fd405/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30322e706e67)](https://camo.githubusercontent.com/58dd9f814783e62a2104343b132f62a079e683405f40c06ea35a6abfe44fd405/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30322e706e67)

  `MySQL` 中数据是以页为单位，查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中。

  后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 `IO` 开销，提升性能。

  更新表数据的时候，也是如此，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。

  然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。

  [![img](https://camo.githubusercontent.com/2d16351f0a69d8b8f6fdd64f4df08d45349992e9750eb8bd37f3ca5eaa7b3421/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30332e706e67)](https://camo.githubusercontent.com/2d16351f0a69d8b8f6fdd64f4df08d45349992e9750eb8bd37f3ca5eaa7b3421/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30332f30332e706e67)



## binlog

binlog（二进制日志）：属于`MySQL Server` 层，包含所有更新数据的语句。二进制日志事件描述了用于重现服务器上发生的相同全局状态更改的操作，可用于`MySQL`数据库的**数据备份**。

![img](https://camo.githubusercontent.com/c77253a8cf26dec2b3785466eab2400fa60b57257873c61b81405ff65cbefb6f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30342f30312e706e67)

### 记录类型

`binlog` 日志有三种格式

- **statement**
- **row**
- **mixed**

#### statement

基于**语句(statement)**的日志记录：记录包含使用DML的语句。

![img](https://camo.githubusercontent.com/6ea6e82a0aa3997ba55f3bad13c5fbe8059a275b5181176eb1ed71096407fb8f/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30342f30322e706e67)

* 不需要记录每行的变化，日志量较少，性能较高
* 无法记录使用了函数的语句.如`update T set update_time=now()`中`update_time=now()`获取的是当前系统时间，直接执行会导致与原库的数据不一致

#### row

基于**行(row)**的日志记录：事件描述对单个行的更改。

![img](https://camo.githubusercontent.com/60f24cf211caea2fbbc5cb1274f5c307aeb63e9bad0905ddccbc8b37c32132fe/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30342f30332e706e67)

* 需要较大的容量来记录，比较占用空间
* 恢复与同步时会更消耗`IO`资源，影响执行速度

#### mixed

混合日志记录默认情况下使用**基于语句**的日志记录，但是会根据需要**自动切换**到**基于行**的日志记录。

### 写入机制

事务执行过程中，先把日志写到`binlog cache`，事务提交的时候，再把`binlog cache`写到`binlog`文件中。

![img](https://camo.githubusercontent.com/4ac4a163c07cdcbeaaae3440f714a302824a21192941184a5cde3c9c9b06a617/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30342f30342e706e67)

每次提交事务都会把日志写入到文件系统缓存中，但将文件缓存的内容写到硬盘上的时机由参数`sync_binlog`控制，默认由系统自行判断执行时机。

## 两阶段提交

两阶段提交能够有效解决 redo log 和 binlog 因程序发生异常重启而导致的数据不一致的问题。

![img](https://camo.githubusercontent.com/12475e1d28c977069f6abe5e4979de20a4226fc29e23ad791346a08c81e243a7/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f31383730323532343637362f434e44352f696d6167652f6d7973716c2f30352f30342e706e67)

当程序发生异常重启，MySQL 的处理过程如下：

- 判断 redo log 是否完整，如果判断是完整的，就立即提交。
- 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

