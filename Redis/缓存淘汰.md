## 缓存淘汰

由于内存的空间资源有限，因此需要淘汰部分内容：应用程序给缓存数据设置一个超时时间TTL，Redis负责将其删除。

### 淘汰策略
* noeviction：返回错误，不会删除任何键值
* volatile-ttl：从设置了过期时间的键中删除剩余时间最短的键
* **<u>Random</u>**
  * allkeys-random：从所有key随机删除
  * volatile-random：从设置了过期时间的键的集合中随机删除
* **<u>LRU</u>**
  * allkeys-lru：使用LRU算法删除最近最少使用的键值
  * volatile-lru：使用LRU算法从设置了过期时间的键集合中删除最近最少使用的键值
* **<u>LFU</u>**
  * allkeys-lfu：从所有键中删除使用频率最少的键
  * volatile-lfu：从配置了过期时间的键中删除使用频率最少的键

### 缓存异常
#### 缓存穿透

缓存穿透：查询的数据在Redis和数据库中都不存在。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20211102151216.png)
解决方法：

1. 使用布隆过滤器过滤掉一定不存在的数据。(<u>不能完全过滤掉不存在的数据</u>)
2. 将key-value对写为key-null并设置较短的过期时间

 #### 缓存击穿

缓存击穿： 当热点数据过期被删除后，突然出现对该数据的大量访问请求。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20211102151238.png)

 解决方法：

1. 设置热点数据永不过期
2. 使用互斥锁

 #### 缓存雪崩

缓存雪崩：大批数据几乎同时失效，接着出现对这些数据的大量访问请求。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20211102151254.png)

解决方法：

1. 随机化数据的TTL
2. 一般并发量不是特别多的时候，可以加锁排队

 ## 参考资料
 * [我是Redis，MySQL大哥被我害惨了！](https://mp.weixin.qq.com/s/FLqhzfVkakwBjLqIJ-1ezA)
 * [2020 年最新版 68 道Redis面试题，20000 字干货，赶紧收藏起来备用！](https://zhuanlan.zhihu.com/p/112944545)