---
title: "死锁"
date: 2021-05-02T00:13:24+08:00
draft: false
toc: true
images:
tags:
  - OS
---

# 死锁

[TOC]

**死锁(deadlock)**： 在[进程同步](%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD.md)的情况下，有一组线程因为组内所有线程都在等待组内其他线程释放资源而**相互无限等待**的现象。
![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124823.png)

## 死锁产生的原因
* 互斥访问：资源只能最多被一个[线程](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E7%BA%BF%E7%A8%8B)持有。
* 资源非抢占：资源只能由持有的[线程](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E7%BA%BF%E7%A8%8B)主动放弃，不能被其他线程抢占。
* **持有并等待**：[线程](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E7%BA%BF%E7%A8%8B)拥有一些资源并等待一些资源。
* **循环等待**： 多个[线程](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E7%BA%BF%E7%A8%8B)形成一个循环，在该循环中每个线程都在等待下一个线程释放资源。

## 死锁的检测与恢复
不试图阻止死锁，而是当检测到死锁发生时，由操作系统等第三者采取措施进行恢复。
* 检测
	
	* 若一种资源只能被一个线程占有： 检测资源和线程形成的有向图是否形成环路，若有环路说明出现循环等待，即出现死锁。
		![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210502175635.png)
	
	* 若一种资源可被多个线程占有：使用**拓扑排序**算法。
	
* 恢复
  * 直接kill所有循环中的进程
  * 每次Kill一个线程，直到没有环
  * 线程全部**回滚**到之前的某一状态

## 死锁预防
在线程运行之前，破坏掉[死锁产生的原因](#死锁产生的原因)中的四个必要条件。
### 避免互斥访问
设计一个**代理线程**专门管理对共享数据的访问与修改。
缺点：修改困难，且为系统带来多余负担。
### 不允许持有并等待
**一次性申请所有资源**，一旦有需要获取的资源被其他线程持有，则主动放弃之前已经持有的资源。
缺点：在资源竞争程度较高时，有可能出现持有-放弃的循环，即出现**活锁**。
> 活锁：锁的竞争线程长时间无法进入临界区，没有一个线程占有该锁。
> 解决方法：线程在获取锁失败后等待随机时间再开始尝试，如[CSMA](../Net/数据链路层.md#CSMA)使用的二进制退避算法。

### 允许资源被抢占
允许线程抢占已经被其他线程持有的资源。
缺点：需要保证被抢占的线程能够正确恢复，只适用于容易保存和恢复的场景。
### 避免循环等待
* 所有资源进行编号
* 所有进程递增获取

<u>任意时刻：获取最大资源号的进程可以继续执行，然后释放资源</u>

## 死锁避免
**运行时避免死锁**：当有资源需要分配时，**系统**检查此次资源分配后是否处于**安全状态**，只有处于安全状态才给线程该资源，否则阻塞进程。

> 安全状态：存在至少一个安全序列<P1,P2,…,Pn>，系统按照该序列调度线程执行即可避免死锁。

###  银行家算法

每次分配资源时，执行**安全性算法**，检查是系统否处于安全状态。

安全性算法：

1. 模拟分配资源：如果某线程所需的资源**可以被满足并且没有被标记**，则将该线程已经占用的资源加到总资源（模拟尝试将资源全部分配给某一线程，执行完后释放该线程占有的所有资源），并标记该进程，重复该操作直到所有线程都被标记或找不到这样的线程。

2. 若所有线程都被标记，则说明系统是安全的，否则说明系统处于非安全状态。


