---
title: "进程与线程"
date: 2021-04-27T00:13:24+08:00
draft: false
toc: false
images:
tags:
  - OS
---

# 进程

[TOC]

进程是计算机程序运行时的抽象。

* 静态部分：程序运行需要的代码和数据
* 动态部分：程序运行期间的状态

## 进程的状态
* 新建状态（ new ）：进程刚被创建，还没有被初始化
* 运行状态（ running ）：进程正在处理器上运行
* 准备状态（ ready ）：进程可以运行，但没有被调度
* 阻塞状态（ blocked ）：进程进入等待状态，短时间不再运行
* 终结状态（ terminated ）：进程完成了执行

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124847.png)

~~程序读取用户输入到显示器输出信息的过程：~~

1. ~~当数据被输入后，Shell会接收到该命令，并请求内核创建相应的进程以及处理命令。当内核创建出新进程后，该进程处于新生状态。~~

2. ~~内核初始化进程需要的相关数据结构，并将其交给长期调度器，加入运行队列，使该进程进入准备状态。~~

3. ~~短期调度器选择该进程执行，此时进程进入运行状态，开始执行相关代码。~~

   

## 地址空间
进程具有**独立的<u>虚拟地址</u>空间**：

![memory layout](https://i.stack.imgur.com/W3mt0.png)

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124846.png)

所有任务**共享内核地址空间**

## 进程控制块

**Process Control Block（PCB）**是保存进程状态的数据结构，存放进程相关的各种信息，如进程的标识符（PID）、内存、打开的文件及进程在切换时的状态([上下文切换](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2))

> Linux中，使用`mm_struct`结构体描述

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124848.png)

## 上下文切换

进程的上下文：进程执行活动全过程的**<u>静态描述</u>**，用于保存和恢复一个进程在CPU上运行的状态。


![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124849.png)

上下文的切换流程：

1. 挂起一个进程，将这个进程在CPU中的上下文存储于内存的PCB中。
2. 在PCB中检索下一个进程的上下文并将其在CPU的寄存器中恢复。
3. 跳转到程序计数器所指向的位置并恢复该进程。

### Linux实现

在Linux内核中，进程上下文包括进程的**<u>虚拟地址空间</u>**和**<u>硬件上下文</u>**。其进程上下文切换主要涉及到两部分主要过程：

* 进程地址空间切换：主要对应用户态进程，将即将执行的进程的**<u>页全局目录的物理地址</u>**（保存在进程地址空间`mm_struct`的`pgd`）设置到**<u>页表基址寄存器</u>**中
* 处理器状态(硬件上下文)切换：
   	1. 处理器状态切换就是将前一个进程的sp,pc等寄存器的值保存到一块内存上
      	2. 将即将执行的进程的sp,pc等寄存器的值从另一块内存中恢复到相应的寄存器中，恢复sp完成了进程内核栈的切换，恢复pc完成了指令执行流的切换

## 进程的基本操作接口
以下操作以Linux的进程操作为例。
### 进程创建：fork()
fork()：为调用进程创建一个一模一样的新进程
* 调用进程为父进程，新进程为子进程
* 接口简单，无需任何参数
* fork后的两个进程均为独立进程，拥有不同的PID

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124850.png)

> fork为进程之间建立了父进程和子进程的关系
> ![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124851.png)
> 多个进程可以属于同一个进程组
>
> * 子进程默认与父进程属于同一个进程组
> * 可以向同一进程组中的所有进程发送信号
> * 主要用于shell程序中

### 进程的执行：exec
在fork完成之后，在多数情况下需要子进程执行与父进程不同的任务。为了实现该目标，Linux提供了exec接口。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124853.png)

# 线程
线程是OS**资源分配和调度**的基本单位。
## 为什么需要线程
* 创建进程的开销较大-包括了数据、代码、堆、栈等
* 进程的隔离性过强：可以通过进程间通信（IPC），但开销较大
* 进程内部无法支持并行

## 线程的地址空间
线程只包含**运行时的状态**，静态部分由进程提供。
* 每个线程包括了执行所需的最小状态（主要是寄存器和栈）
* 其它区域共享：	数据、代码、堆……

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124854.png)



## 线程模型

根据线程是否受内核管理，可以将线程分为两类
* 内核态线程：由内核创建及管理，线程相关信息存放在内核中
* 用户态线程（**纤程**）：不受内核直接管理，在应用态创建，线程相关信息主要存放在应用数据中
***
**线程模型**会建立用户态线程与内核态线程之间的联系。这种联系可分为[多对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)、[一对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)和[多对多模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%A8%A1%E5%9E%8B)。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124852.png)



### 多对一模型
将多个用户态线程映射给单一的内核线程。内核管理简单但可扩展性差，无法适应多核机器的发展。

用途：在主流操作系统中被弃用，用于各种**用户态线程库**。
### 一对一模型
每个用户线程映射单独的内核线程。解决了[多对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)中的可扩展性问题，但内核线程数量大，开销大。

用途：主流操作系统都采用一对一模型，如Windows、Linux。

### 多对多模型
多对多模型（又叫Scheduler Activation）：N个用户态线程映射到M个内核态线程（N > M）。解决了[多对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)中的可扩展性问题和[一对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)的线程过多问题，但管理变得更为复杂。
用途：在虚拟化中得到了广泛应用。

## 线程控制块
线程控制块TCB和[进程控制块](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97)类似，对于[一对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E4%B8%80%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)的TCB可以分成两部分：
* 内核态：与PCB结构类似，包括线程标识符、线程优先级等等。
* 应用态：主要由线程库决定，可以认为是内核TCB的扩展。

> ChCore的TCB结构:
>![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124855.png)
## 线程本地存储
问题：对于全局变量，不同线程可能需要不同的拷贝
解决方法：线程本地存储（Thread Local Storage， TLS）

线程本地存储用于保存线程自身相关的信息。

> 例：__thread int id; 会为每个线程定义一个独有的id变量
![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124856.png)
TLS寻址模式：基地址＋偏移量

## 进程和线程的区别
* **资源**：进程是资源分配的基本单位，进程资源包括<u>内存地址、页表和内核资源、CPU中的缓存</u>等；而线程不拥有系统资源，只拥有一些<u>寄存器、栈和程序计数器</u>等，与同属于一个进程的不同线程共享进程所拥有的全部资源。
* **调度**：线程是OS调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
* **开销**：创建或撤销进程的[进程控制块](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97)所付出的开销远大于创建或撤销线程的[线程控制块](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97)的开销。在进行上下文切换时，进程的上下文远比线程的上下文的内容多，付出的开销也更大。
* **通信**：线程间可以通过直接读写同一进程中的共享数据进行通信，但是进程通信需要通过进程间通信。
* **安全性**：进程崩溃或者缓冲区溢出，不会影响其他进程。线程崩溃会导致其所属进程的其他所有线程被关闭，而线程缓冲区溢出则影响其所属进程的其他线程的安全性

> 根据 Linux Kernel 文档，除了**<u>线程使用共享虚拟地址空间</u>**与进程不同之外，线程与进程之间没有明显区别。

# 纤程
纤程（fiber）：一种**用户态线程**，即<u>把OS的内核调度器的调度权让给应用程序</u>，有助于做出更优的调度决策。和一般的线程不同的是纤程采取**<u>合作式多任务（Cooperative multitasking）</u>**，而线程采取抢占式多任务（Pre-emptive multitasking）。

> 合作式多任务:  只有当进程自愿周期性地放弃控制，或者空闲或逻辑阻塞以允许多个应用程序同时执行时，才会发生上下文切换。此外，在这种多任务处理中，所有进程都协作以使调度方案工作。

一个内核线程可以对应多个纤程，即[多对一模型](%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E5%A4%9A%E5%AF%B9%E4%B8%80%E6%A8%A1%E5%9E%8B)。

* 相对于内核线程，创建**开销更小**

* 上下文切换不需要进入内核，**切换更快**

  ![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124857.png)

## 参考
[上海交通大学SE-315 · 操作系统（2020春)](https://ipads.se.sjtu.edu.cn/courses/os/2020/schedule.shtml)




