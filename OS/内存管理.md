---
title: "内存管理"
date: 2021-04-27T00:13:24+08:00
draft: false
toc: true
images:
tags:
  - OS
---

[TOC]



## 虚拟内存
虚拟内存： 为了让不同的[进程](OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B)**高效安全**地使用物理内存资源，加入一个在**应用程序**与**物理内存**之间的抽象。
* 高效性：虚拟内存抽象下，**程序**使用虚拟地址访问主存，不会造成明显的性能开销。
* 安全性：每个应用程序拥有**独立**的虚拟地址空间，且只能访问属于自己的物理内存区域。
	* 应用程序认为自己独占整个内存
	* 应用程序不再看到物理地址

***
地址翻译： 在程序执行过程中，CPU中的**内存管理单元**（MMU, Memory Management Unit）会根据**翻译规则**把虚拟地址转换成物理地址，然后通过物理地址访问物理内存。
> 翻译规则取决于虚拟内存采用的组织机制，包括：分段机制和分页机制。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124456.png)

## 分段机制

地址空间分成若干个**不同大小**的**逻辑段**，如代码段、数据段等。

翻译过程：
![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124457.png)

1. MMU通过段表寄存器找到段表的位置，结合虚拟地址中的段号得到该段的起始地址（**物理地址**）。
2. **起始地址**加上虚拟地址中的**段内偏移地址**得到最终的物理地址。


存在问题：
* 分配的粒度太粗，容易导致物理内存上段与段之间留下**碎片空间**，不足以映射虚拟地址空间的段，**降低主存利用率**。

因此Intel在x86-64架构之后，[分页机制](%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6)成为主流。

## 分页机制

![undefined](https://cdn.buttercms.com/KdQFc7OFQDeBANYrl2ff)

分页机制：将**虚拟内存**划分成**连续的、等长的虚拟页**。该机制实现了相比[分段机制](%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6)更细粒度的内存管理，大大缓解分段机制中常见的外部碎片。
![100](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124458.png)

* **物理内存**也划分成**连续的、等长的物理页**
* 虚拟页和物理页**页长固定**且**相等**
* 虚拟地址 = **虚拟页号**+**页内偏移**

### 页表

页表包含多个页表项，**存储虚拟页到物理页的映射**等信息，分页机制的核心数据结构。在创建[进程](OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B)时，OS会为每个进程分配一个页表，同时在[PCB](OS/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.md#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97)中记录页表的初始地址和页表的长度等内容。

* **地址转换** ：将虚拟地址转换为物理地址 
* **权限管理** ：控制CPU对物理页的访问权限
* **隔离地址空间** ：隔离各个进程的地址空间，使其互不影响，提高系统的安全性

### 翻译过程
![200](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124502.png)

1. MMU解析虚拟地址中的**虚拟页号**，首先在**<u>TLB</u>**中查找虚拟页号对应的物理页号，如果找不到，则通过**<u>页表基地址寄存器</u>**保存的页表基地址找到该进程的**页表**，从该页表中查找虚拟页号对应的物理页号。
2. 根据物理页号对应的**物理页起始地址**加上虚拟地址中的**页内偏移地址**得到最终的物理地址。

<u>注意：实际上还有一个长度寄存器用于判断页内偏移地址是否超出页表的范围。</u>

### 多级页表
使用多级页表可以**<u>减少空间占用，按需分配页表</u>**：
* 实际应用的虚拟地址空间大部分都未被使用，没有必要为这些空间分配页表

* 如果某级页表中的某条目为空，则对应的下一级页表无需存在，即允许页表中出现"空洞"。因为除了0级页表，其他页表的位置由上一级页表的页表项存储，而非以**数组的索引形式**表示

  

  ![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124459.png)



### TLB
**TLB:Translation Lookaside Buffer**，起到类似于cache的作用，缓存了虚拟页号到物理页号的映射关系，实际上使用**相联存储器**实现。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124500.png)


在地址翻译过程中，MMU首先查询TLB：

* TLB命中，则不再查询页表（fastpath）
* TLB未命中，再查询页表

#### TLB刷新

为了保证TCB存储的是页表当前的内容，在**页表（进程）进行切换**或**修改页表**内容时，需要主动刷新。

* 进行页表切换时，可以在TLB中缓存页表的ID，从而区分属于不同进程的缓存项，避免刷新。

## 换页机制

当物理内存不够时，OS把若干物理页的内容写到磁盘（在Linux中，写到Swap分区）并回收这些物理页以供新的虚拟页映射，使**虚拟内存的使用不受物理内存大小限制**。

### 过程

​	![undefined](https://cdn.buttercms.com/q84MO5qnTSuClge4MUmW)

* swap out(换出)：当某进程的物理页需要被回收时，将该物理页的内容写到磁盘，并在对应的进程的页表中去除虚拟页的映射，同时记录该物理页被换到磁盘上的对应位置。

* swap in(换入)：当发生缺页异常时，将之前写到磁盘的内容重写到物理页中，同时更新虚拟地址到该物理页的映射。

  >  当进程访问一个处于未分配状态或已分配但未映射到物理内存转态时，将触发**缺页异常(page fault)**。

[Medium-Term Scheduler](OS/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6.md#%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6#Medium-Term%20Scheduler)实际上就是换入和换出。

优化磁盘操作：

* 预取（Prefetching）：换入时，将被访问的物理页临近的物理页也都换入，从而减少缺页异常的次数。
* 按需页分配：当进程申请分配内存时，只将新分配的虚拟页标记成已分配但未映射至物理内存状态，不分配物理页。可节约内存但增加缺页异常的次数。

在实际使用中，一般同时使用预取和按需页分配机制。

### 页面置换算法
#### OPT
最佳(OPT, Optimal replacement algorithm)：又称为MIN(Minimum)，所选择的被换出的页面将是==理论上==**最长时间内不再被访问**，通常可以保证获得最低的缺页率。

#### LRU
最近最久未使用(LRU, Least Recently Used)：将**最近一次访问的时间最久**的页面替换出去。可以使用**链表**实现。

#### NRU
最近未使用(NRU, Not Recently Used)：每个页面都有两个状态位：R(reference) 和 M(modified)。，当页面被引用时设置页面的 R=1，当页面被修改时设置 M=1。<u>其中 R 位会定时被清零</u>。

当发生缺页中断时，按<u>以下顺序</u>从集合中随机选择一个页面将其替换出去：

* Not referenced and not modified（R=0，M=0）
* Not referenced and modified（R=0，M=1）
* Referenced and not modified（R=1，M=0）
* Referenced and modified（R=1，M=1）

> 可以看出，NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）

#### MRU
MRU(Most Recently Used) : 优先将最近访问的物理页换出，基于<u>程序不会反复访问相同的地址</u>的假设。如播放视频时，每帧数据一般不会读取第二次。

#### FIFO
先进先出(FIFO, First In First Out)：维护一个先进先出的队列，优先将**最先换入内存**的页换出去。
#### Second Change
[FIFO](%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#FIFO)的改进版本，同样使用一个先进先出的队列，但每个物理页号有一个**访问标志位**，如果访问的页号已经在队列中，则将该标志位置1。该策略优先查看队头的页号，若标志位为1则将其清零并将对应的页号移向队尾，否则将该页号对应的物理页换出。

> Second Change 和 FIFO算法有可能导致出现Belady异常，即物理页的数量越多，换页的数量也越多。
#### Clock
时钟(Clock)：和[Second Change](%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md#Second%20Change)类似，但不需要移动页号，所以更加高效。

![](https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210424124501.png)

指针指向的页号若标志位为1则将指针向前移动一位（类似于时钟），同时将该标志位清零，直到找出标志位为零的页面将其替换出去。

### 颠簸

颠簸(Thrashing)：CPU 的大部分时间都被用来处理缺页异常，仅剩小部分的时间用于执行真正有意义的工作，导致CPU利用率低下。

![img](https://media.geeksforgeeks.org/wp-content/uploads/2-103.png)



原因：OS为进程分配的**物理页过少**或者**进程数量太多**，出现频繁的页面换出和换入，导致CPU利用率将急剧下降。然后，长期调度器将更多进程加载到内存中以提高CPU利用率，从而触发更多的缺页异常，进一步降低CPU利用率，导致连锁反应。

#### 工作集模型

**工作集(working set)**：进程正在使用的页面集合，一般通过计算最近**T秒**内进程引用的所有页面集合得到。

* 将进程分为两组：active 和 inactive
  - 当一个进程处于 active 时，它的工作集必须**<u>始终在内存</u>**。
  - 当一个进程处于 inactive 时，它的工作集可以**<u>迁移到磁盘</u>**。
  - 系统必须有一个机制调整活动进程的集合。
* 如果所有可运行线程的所有工作集的总和超过内存大小，应该通过中期调度器暂时停止运行某些线程，使其变成inactive线程。

#### 缺页异常频率

**缺页异常频率（Page Fault Frequency）**：为每个进程分配不同的物理页，同时监视每个进程的缺页异常频率：

* 如果缺页异常频率太高，则增加该进程的物理页数量，如果找不到合适的物理页，即所有进程需要的物理页过多，则暂停某些进程。
* 如果缺页异常频率太低，则减少该进程的物理页数量。

## 分页与分段的对比

* 相同点
  * 都离散地管理了进程的逻辑空间
* 不同点
  * **透明性**：分页透明;分段需要程序员显式划分每个段。
  * **大小是否可以改变**：页的大小不可变且相等（由硬件决定）;段的大小可以动态改变且不一定相等。
  * **地址空间的维度**：分页是一维地址空间，分段是二维地址空间。
  * **出现的原因**：分页是由于**系统管理**的需要，为了实现非连续分配，以解决内存碎片问题；段是信息的逻辑单位，分段的目的是为了能更好地满足程序员的需要。

## 段页式机制

段页式管理机制：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页，也就是说段页式管理机制中段与段之间以及段的内部的都是离散的。

地址结构由**段号、段内页号和页内位移**三部分组成。

![img](https://pica.zhimg.com/80/v2-975920d028e58f620ca84125c1b211f4_720w.jpg?source=1940ef5c)

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。



## 参考
* [上海交通大学SE-315 · 操作系统（2020春)](https://ipads.se.sjtu.edu.cn/courses/os/2020/schedule.shtml)
* [Virtual Memory Paging and Caching - Princeton University ](https://www.cs.princeton.edu/courses/archive/fall17/cos318/lectures/12.VM-Design-Paging.pdf)
* [Techniques to handle Thrashing - GeeksforGeek](https://www.geeksforgeeks.org/techniques-to-handle-thrashing/)
* [Thrashing and Working Sets - Stanford University](https://web.stanford.edu/~ouster/cgi-bin/cs140-winter12/lecture.php?topic=thrashing)
* [计算机操作系统 - 内存管理](http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html)

