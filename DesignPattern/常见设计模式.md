---
title: "常见设计模式"
date: 2021-05-10T00:13:24+08:00
draft: false
toc: true
comment: true
images:
tags:
  - Design Pattern
---


[TOC]

## 概述

* 构造型模式（Creational patterns）
  * 工厂模式
  * 单例模式
  * 建造者模式

* 结构型模式（Structural patterns）
  * 代理模式
  * 装饰模式
  * 外观模式
  * 适配器模式
* 行为型模式（Behavioral patterns）
  * 策略模式
  * 观察者模式
  * 迭代器模式
  * 模板方法模式
    

## 工厂模式

**工厂模式(Factory)**：在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口（工厂），适用于生产**不需要过多修改的标准的产品**，属于[构造型模式（Creational patterns）](目录#构造型模式（Creational%20patterns）)之一。

具体可分为三种：

* [简单工厂](工厂模式#简单工厂)(Simple Factory)
* [工厂方法](工厂模式#工厂方法)(Factory Method)
* [抽象工厂](工厂模式#抽象工厂)(Abstract Factory)

### 简单工厂

#### 概述

简单工厂(Simple Factory)：负责多个类型的产品的生产。

* 消费者任何时候需要某种产品，只需向工厂请求即可，无须修改就可以接纳新产品。
* 当产品修改时，工厂类也要做相应的修改。

#### 实现

<img src="https://pic1.zhimg.com/80/v2-be10b797353d00462841ba979ca0f090_720w.jpg" alt="img" style="zoom:80%;" align="left"/>

* 单个SimpleFactory：简单工厂角色-负责实现创建所有实例的内部逻辑.
* 单个Product：抽象产品角色-是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。
* 多个ConcreteProduct：具体产品角色-是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

```java
public class SimpleFactory {

    public Product createProduct(int type) {
        if (type == 1) {
            return new ConcreteProduct1();
        } else if (type == 2) {
            return new ConcreteProduct2();
        }
        return new ConcreteProduct();
    }
}
```

```java
public class Client {

    public static void main(String[] args) {
        Factory factory = new Factory();
        Product product = Factory.createProduct(1);
        // do something with the product
    }
}
```

### 工厂方法

#### 概述

工厂方法(Factory Method)：定义了一个抽象工厂类，并由**具体工厂**负责生产对应的**具体产品**，一个具体工厂对应一个具体产品。

#### 实现

工厂方法模式包含如下角色：
![工厂方法实现-UML类图](https://www.oodesign.com/images/stories/factory%20method%20implementation%20-%20uml%20class%20diagram.gif)

* 单个Product：抽象产品
* 多个ConcreteProduct：具体产品
* 单个Factory：抽象工厂
* 多个ConcreteFactory：具体工厂

***

```java
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething() {
        Product product = factoryMethod();
        // do something with the product
    }
}
```

```java
public class ConcreteFactoryA extends Factory {
    public Product createProduct() {
        return new ConcreteProduct1();
    }
}
```

```java
public class ConcreteFactoryB extends Factory {
    public Product createProduct() {
        return new ConcreteProduct2();
    }
}
```

```java
public class FactoryMethod
{
    public static void main(String[] args)
{
        Factory factory = new ConcreteFactoryA();
        Product product = factory.createProduct();
        // do something with the product
    }
}

```

### 抽象工厂

#### 概述

抽象工厂(Abstract Factory)：提供一个抽象工厂，一个具体工厂用于生产==多个相关的产品==，而[工厂方法](工厂模式#工厂方法)中一个具体工厂只生产一个产品。

#### 实现

![img](https://www.oodesign.com/images/creational/abstract-factory-pattern.png)

* 单个Product：抽象产品
* 多个ConcreteProduct：具体产品
* 单个Factory：抽象工厂
* 多个ConcreteFactory：具体工厂

```java
public class AbstractProductA {
}
public class AbstractProductB {
}
public class ProductA1 extends AbstractProductA {
}
public class ProductA2 extends AbstractProductA {
}
public class ProductB1 extends AbstractProductB {
}
public class ProductB2 extends AbstractProductB {
}
public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
```



## 单例模式

### 概述

**单例模式(Singleton)**：确保一个类只有一个实例，并提供该实例的全局访问点，适合需要做**全局统一控制**的场景，属于[构造型模式（Creational patterns）](目录#构造型模式（Creational%20patterns）)之一。

* 便于统一控制，同时减少了创建对象带来的资源开销。
* 没有抽象层，扩展困难。

### 实现

![img](https://pic3.zhimg.com/80/v2-7364643d9863aeb5b1d12cd86ccb32c6_720w.jpg)
使用一个**私有构造函数**、一个**私有静态变量**以及一个**公有静态函数**来实现。
具体可分为[饿汉式](单例模式#饿汉式)和[懒汉式](单例模式#懒汉式)。

#### 饿汉式

直接实例化，不会产生线程不安全问题，但不节约资源。

```java
public class Singleton {

    private volatile static Singleton uniqueInstance = new Singleton();

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        return uniqueInstance;
    }
}
```

#### 懒汉式

懒汉式可能会产生==线程不安全==问题，因此需要用`synchronized`锁住这个类，判断 `uniqueInstance` 是否已经被实例化。

* 使用`volatile`修饰 `uniqueInstance`，防止[JVM](../Java/JVM.md)对指令进行重排
* 在加锁前先判断`uniqueInstance`是否实例化可以避免额外开销

```java
public class Singleton {

    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {//避免在已经确定实例化的情况下加锁,降低额外开销
            synchronized (Singleton.class) {//
                if (uniqueInstance == null) {//确保只有一个实例
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

## 代理模式

### 概述

**代理模式(Proxy)**：协调调用方与被调用方，根据代理类型和场景的不同，可以起到控制安全性、减小系统开销等作用，属于[结构型模式（Structural patterns）](目录#结构型模式（Structural%20patterns）)之一。

* 降低系统的**耦合度**
* 增加了系统的复杂度，可能会降低系统的**响应速度**

### 类型

* 远程代理（Remote Proxy）：为远程对象（不同地址空间）提供一个**本地的代理对象**，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又叫做大使(Ambassador)。
* 虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
* 保护代理（Protection Proxy）：根据**权限**控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
* 智能代理（Smart Reference）：当一个对象被**引用**时，提供一些**额外的操作**，如将此对象被调用的次数记录下来等。

### 实现

代理模式包含如下角色：

<img src="https://pic3.zhimg.com/80/v2-e2d1cf3eb05167dae16df3dc2222d40e_720w.jpg" alt="img" style="zoom:67%;" align="Left"/>

* Subject: 抽象主题角色

* Proxy: 代理主题角色

* RealSubject: 真实主题角色

<img src="https://pic3.zhimg.com/80/v2-a94835cbadd5731793046c1b1bafb29e_720w.jpg" alt="img" style="zoom: 67%;" align="left"/>

```java
interface Subject{
    void request();
}
```

```java
class RealSubject implements Subject{
    public void request(){
        //do sth.
    }
}
```

```java
class Proxy implements Subject{
    private RealSubject realSubject;
    public void request(){
        if (realSubject==null)
        {
            realSubject=new RealSubject();
        }
        preRequest();
        realSubject.request();
        afterRequest();
    }
    public void preRequest(){
        //do pre request
    }
    public void afterRequest(){
       // do after request
    }
}

```

```java
public class Client{
    public static void main(String[] args){
        Proxy proxy = new Proxy();
        proxy.request();
    }
}
```

## 装饰模式

### 概述

**装饰模式(Decorator)**：通过**装饰器(decorator)**，为装饰者**动态添加功能**，使得<u>装饰者在保留原有功能的同时增加新的功能</u>，适用于对象功能需要**动态变化**的场景属于[结构型模式（Structural patterns）](目录#结构型模式（Structural%20patterns）)之一。

* 比继承更加灵活，通过使用不同的装饰器**组合**为对象**动态扩展**N个新功能，而**不会影响到对象本身**。
* 当一个对象的装饰器过多时，会产生很多的装饰类小对象和装饰组合策略，**增加系统复杂度和代码的阅读成本**。

### 实现

装饰模式包含如下角色：

* Component：抽象构件
* ConcreteComponent：具体构件
* Decorator：抽象装饰类
* ConcreteDecorator：具体装饰类

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210509204900.png" style="zoom:80%;" align="Left"/>

```java
public class DecoratorPattern
{
    public static void main(String[] args)
{
        Component component = new ConcreteComponent();
        component.operation();
        component = new ConcreteDecorator(component);
        component.operation();
    }
}
```

## 策略模式

### 概述

**策略模式（Strategy）**： 定义并封装一系列算法，使用对象可以在**不需要知道算法的细节**的情况下**使用不同的策略**，属于[行为型模式（Behavioral patterns）](目录#行为型模式（Behavioral%20patterns）)之一。

* 遵守[开闭原则](设计原则#开闭原则)，用户可以在不修改原有系统的基础上选择算法。
* 调用时需要使用者自行决定使用何种策略，因此应在策略类的注释中说明该策略的用途和适用场景。

### 实现

策略模式包含如下类：

* Context: 环境类
* Strategy: 抽象策略类
* ConcreteStrategy: 具体策略类

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210509192525.png" style="zoom:80%;" align="left"/>



```java
package strategy;
public class StrategyPattern
{
    public static void main(String[] args)
{
        Context context = new Context();
        Strategy strategyA = new ConcreteStrategyA();
        context.setStrategy(strategyA);
        context.algorithm();
        Strategy strategyB = new ConcreteStrategyB();
        context.setStrategy(strategyB);
        context.algorithm();
    }
}
//抽象策略类
interface Strategy
{   
    public void algorithm();    //策略方法
}
//具体策略类A
class ConcreteStrategyA implements Strategy
{
    public void algorithm()
{
        System.out.println("具体策略A的策略方法被访问！");
    }
}
//具体策略类B
class ConcreteStrategyB implements Strategy
{
  public void algorithm()
{
      System.out.println("具体策略B的策略方法被访问！");
  }
}
//环境类
class Context
{
    private Strategy strategy;
    public Strategy getStrategy()
{
        return strategy;
    }
    public void setStrategy(Strategy strategy)
{
        this.strategy=strategy;
    }
    public void algorithm()
{
        strategy.algorithm();
    }
}
```

## 观察者模式

### 概述

**观察者模式（Observer）**：当被观察者的状态改变时，它的所有观察者都会收到通知并且自动处理，适用于==一对多==的的业务场景，一个对象发生变更，会触发N个对象做相应处理的场景（如订单调度通知，任务状态变化等）,属于[行为型模式（Behavioral patterns）](目录#行为型模式（Behavioral%20patterns）)之一。
<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210509195442.png" style="zoom:50%;" />

* 将复杂的**串行处理逻辑**变为单元化的**独立处理逻辑**，被观察者只需根据自己的逻辑发出消息，不用关心消费消息的对象，每个观察者只处理自己关心的内容。

* 观察者较多时，可能会花费一定的开销来发消息，但消费消息的观察者比例可能很少，甚至只有一个观察者消费。
* ==避免观察者与被观察者之间形成循环依赖，可能会因此导致系统崩溃。==

### 实现

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210509195437.png" style="zoom:80%;" />
观察者模式包含如下角色：

* Subject：目标
* ConcreteSubject：具体目标
* Observer：观察者
* ConcreteObserver：具体观察者

<img src="https://raw.githubusercontent.com/cluckl/Pinnned-repo/master/img/20210509195534.png" style="zoom: 80%;" />
主题（Subject）具有**添加**和**移除**观察者、并**通知所有观察者**的功能，主题是通过维护一张==观察者列表==来实现这些操作的。

```java
interface Observer{
    void process(); //具体的处理
}

class ConcreteObserverA implements Observer{
    public void process(){
        // process by observer A
    }
}

class ConcreteObserverB implements Observer{
    public void process(){
        // process by observer B
    }
}
```

```java
abstract class Subject{
    protected List<Observer> observerList = new ArrayList<Observer>();   
  
    public void add(Observer observer)
    {
        observers.add(observer);
    }    
    
    public void remove(Observer observer)
    {
        observers.remove(observer);
    }   
    public abstract void notify(); 
}

class ConcreteSubject extends Subject
{
   private Integer state;
   public void setState(Integer state){
        this.state = state;
        notify();
   }
   public void notify(){
		// notify all observers
        for(Observer obs:observers)
        {
            obs.process();
        }

   }          
}
```

```java
public class ObserverPattern
{
    public static void main(String[] args){
        Subject subject = new ConcreteSubject();
        Observer obsA = new ConcreteObserverA();
        Observer obsb = new ConcreteObserverB();
        subject.add(obsA);
        subject.add(obsB);
        subject.setState(0);
    }
}
```

## 建造者模式
### 概述

**建造者模式(Singleton)**：为了**分离对象的属性与创建过程**，适合初始化属性过多的对象时，很多属性具有默认值或者属性之间有关联的场景，属于[构造型模式（Creational patterns）](目录#构造型模式（Creational%20patterns）)之一。

* 客户端不需要知道产品内部实现细节，将产品本身与产品创建过程解耦，使得相同的创建过程可以创建不同的产品对象
* 可以更加精细地控制产品的创建过程，将复杂对象分为不同的类别，使得开发者可以更加方便地得到想要的产品
* 不适用与产品属性之间差异很大且属性没有默认值的场景

## 外观模式

外观模式（Facade）：提供了一个统一的API，用来访问子系统中的一系列API，从而让子系统更容易使用。属于**<u>最少知识原则</u>**的运用。

> 迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP）：一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

## 适配器模式

适配器模式（adapter）：把一个类的API转换成另一个调用方需要的API，使该API适配调用方。

## 模板方法

模板方法（Template Method）：定义算法框架，并将一些**<u>步骤延迟到子类实现</u>**。

* 子类可以在不改变一个算法的结构的前提下重定义该算法的某些特定步骤，以减少**<u>代码重复</u>**问题

## 参考

* [如何理解这6种常见设计模式？-知乎 - 阿里云云栖号](https://zhuanlan.zhihu.com/p/248098212)
* [CS-Notes-设计模式](http://www.cyc2018.xyz/%E5%85%B6%E5%AE%83/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.html#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80)
* [Design Patterns](http://www.oodesign.com/)